import type { AnyStructure, Vec3 } from '$lib'
import { electro_neg_formula } from '$lib'
import { download } from '$lib/io/fetch'
import * as math from '$lib/math'

// Generate a filename for structure exports based on structure metadata
export function create_structure_filename(
  structure: AnyStructure | undefined,
  extension: string,
): string {
  if (!structure) return `structure.${extension}`

  const parts: string[] = []

  if (structure.id) parts.push(structure.id) // Add ID if available

  // Add formula
  const formula_html = electro_neg_formula(structure)
  if (formula_html && formula_html !== `Unknown`) {
    const formula_plain = formula_html.replace(/<\/?sub>|<\/?sup>/g, ``)
    parts.push(formula_plain)
  }

  // Add space group if available
  if (
    `symmetry` in structure &&
    structure.symmetry &&
    typeof structure.symmetry === `object` &&
    `space_group_symbol` in structure.symmetry
  ) parts.push(String(structure.symmetry.space_group_symbol))

  // Add lattice system if available
  if (
    `lattice` in structure &&
    structure.lattice &&
    typeof structure.lattice === `object` &&
    `lattice_system` in structure.lattice
  ) parts.push(String(structure.lattice.lattice_system))

  // Add number of sites
  if (structure.sites?.length) parts.push(`${structure.sites.length}sites`)

  const base_name = parts.length > 0 ? parts.join(`_`) : `structure`
  return `${base_name}.${extension}`
}

// Generate XYZ content string without saving
export function structure_to_xyz_str(structure?: AnyStructure): string {
  if (!structure?.sites) throw new Error(`No structure or sites to export`)

  const lines: string[] = []

  // First line: number of atoms
  lines.push(String(structure.sites.length))

  // Second line: comment (structure ID, formula, or default)
  const comment_parts: string[] = []
  if (structure.id) comment_parts.push(structure.id)
  const formula = electro_neg_formula(structure)
  if (formula && formula !== `Unknown`) comment_parts.push(formula)

  // Include extended XYZ lattice information when available so round-trips preserve lattice
  if ((`lattice` in structure) && structure.lattice?.matrix?.length === 3) {
    const lattice_values = structure.lattice.matrix
      .flat()
      .map((value: number) => (Number.isFinite(value) ? value : 0).toFixed(8))
      .join(` `)
    comment_parts.push(`Lattice="${lattice_values}"`)
  }

  const comment = comment_parts.length > 0
    ? comment_parts.join(` `)
    : `Generated from structure`
  lines.push(comment)

  // Atom lines: element symbol followed by x, y, z coordinates
  for (const site of structure.sites) {
    // Extract element symbol from species
    let element_symbol = `X` // default fallback
    if (
      site.species &&
      Array.isArray(site.species) &&
      site.species.length > 0
    ) {
      // species is an array of Species objects with element property
      const first_species = site.species[0]
      if (
        first_species && `element` in first_species && first_species.element
      ) element_symbol = first_species.element
    }

    // Get coordinates - prefer xyz; fallback to abc (converted to cartesian if lattice available)
    let coords: number[]
    if (site.xyz && Array.isArray(site.xyz) && site.xyz.length >= 3) {
      coords = site.xyz.slice(0, 3)
    } else if (
      site.abc &&
      Array.isArray(site.abc) &&
      site.abc.length >= 3 &&
      `lattice` in structure &&
      structure.lattice
    ) {
      // Convert fractional coordinates to cartesian
      const [a, b, c] = site.abc
      const lattice = structure.lattice
      if (
        lattice.matrix &&
        Array.isArray(lattice.matrix) &&
        lattice.matrix.length >= 3
      ) {
        const lattice_transposed = math.transpose_3x3_matrix(lattice.matrix)
        coords = math.mat3x3_vec3_multiply(lattice_transposed, [a, b, c])
      } else coords = [0, 0, 0] // fallback
    } else coords = [0, 0, 0] // fallback

    // Format coordinates to reasonable precision
    const [x, y, z] = coords.map((coord) => coord.toFixed(6))
    lines.push(`${element_symbol} ${x} ${y} ${z}`)
  }

  return lines.join(`\n`)
}

// Generate CIF content string without saving
export function structure_to_cif_str(structure?: AnyStructure): string {
  if (!structure?.sites) throw new Error(`No structure or sites to export`)
  if (!(`lattice` in structure) || !structure.lattice) {
    throw new Error(`No lattice information for CIF export`)
  }

  const lines: string[] = []

  // CIF header
  lines.push(`# CIF file generated by MatterViz`)
  if (structure.id) lines.push(`_cell_identifier ${structure.id}`)
  lines.push(``)

  // Cell parameters
  const lattice = structure.lattice
  if (lattice.a && lattice.b && lattice.c) {
    lines.push(`_cell_length_a ${lattice.a.toFixed(6)}`)
    lines.push(`_cell_length_b ${lattice.b.toFixed(6)}`)
    lines.push(`_cell_length_c ${lattice.c.toFixed(6)}`)
  }
  if (lattice.alpha && lattice.beta && lattice.gamma) {
    lines.push(`_cell_angle_alpha ${lattice.alpha.toFixed(6)}`)
    lines.push(`_cell_angle_beta ${lattice.beta.toFixed(6)}`)
    lines.push(`_cell_angle_gamma ${lattice.gamma.toFixed(6)}`)
  }

  // Space group information
  if (
    `symmetry` in structure && structure.symmetry &&
    typeof structure.symmetry === `object`
  ) {
    const symmetry = structure.symmetry as Record<string, unknown>
    if (`space_group_symbol` in symmetry && symmetry.space_group_symbol) {
      lines.push(`_space_group_name_H-M_alt ${symmetry.space_group_symbol}`)
    }
    if (`space_group_number` in symmetry && symmetry.space_group_number) {
      lines.push(`_space_group_IT_number ${symmetry.space_group_number}`)
    }
  }

  lines.push(``)

  // Atom site loop header
  lines.push(`loop_`)
  lines.push(`_atom_site_label`)
  lines.push(`_atom_site_type_symbol`)
  lines.push(`_atom_site_fract_x`)
  lines.push(`_atom_site_fract_y`)
  lines.push(`_atom_site_fract_z`)
  lines.push(`_atom_site_occupancy`)

  // Atom sites
  for (let idx = 0; idx < structure.sites.length; idx++) {
    const site = structure.sites[idx]
    if (!site) continue // Skip if site is undefined

    // Extract element symbol from species
    let element_symbol = `X` // default fallback
    let occupancy = 1
    if (
      site.species &&
      Array.isArray(site.species) &&
      site.species.length > 0
    ) {
      const first_species = site.species[0]
      if (
        first_species && `element` in first_species && first_species.element
      ) {
        element_symbol = first_species.element
        occupancy = first_species?.occu ?? 1
      }
    }

    // Get fractional coordinates
    let frac_coords: number[]
    if (site.abc && Array.isArray(site.abc) && site.abc.length >= 3) {
      frac_coords = site.abc.slice(0, 3)
    } else if (
      site.xyz &&
      Array.isArray(site.xyz) &&
      site.xyz.length >= 3 &&
      lattice.matrix &&
      Array.isArray(lattice.matrix)
    ) {
      // Convert cartesian to fractional coordinates
      const lattice_transposed = math.transpose_3x3_matrix(lattice.matrix)
      const lattice_inv = math.matrix_inverse_3x3(lattice_transposed)
      frac_coords = math.mat3x3_vec3_multiply(lattice_inv, site.xyz)
    } else throw new Error(`No valid coordinates found for site ${idx}`)

    // Format: label element_symbol x y z
    const label = site.label || `${element_symbol}${idx + 1}`
    lines.push(
      `${label} ${element_symbol} ${frac_coords[0].toFixed(8)} ${
        frac_coords[1].toFixed(8)
      } ${frac_coords[2].toFixed(8)} ${occupancy.toFixed(8)}`,
    )
  }

  return lines.join(`\n`)
}

// Generate VASP POSCAR content string without saving
export function structure_to_poscar_str(structure?: AnyStructure): string {
  if (!structure?.sites) throw new Error(`No structure or sites to export`)
  if (!(`lattice` in structure) || !structure.lattice) {
    throw new Error(`No lattice information for POSCAR export`)
  }
  const lines: string[] = []

  const title = structure.id || electro_neg_formula(structure) ||
    `Generated from structure`
  lines.push(title)
  lines.push(`1.0`) // Scale factor (1.0 for direct coordinates)

  const lattice = structure.lattice
  if (lattice.matrix && Array.isArray(lattice.matrix) && lattice.matrix.length >= 3) {
    // Convert 3x3 matrix to 3 vectors
    const matrix = lattice.matrix
    lines.push(
      `${matrix[0][0].toFixed(8)} ${matrix[0][1].toFixed(8)} ${matrix[0][2].toFixed(8)}`,
    )
    lines.push(
      `${matrix[1][0].toFixed(8)} ${matrix[1][1].toFixed(8)} ${matrix[1][2].toFixed(8)}`,
    )
    lines.push(
      `${matrix[2][0].toFixed(8)} ${matrix[2][1].toFixed(8)} ${matrix[2][2].toFixed(8)}`,
    )
  } else {
    throw new Error(`No valid lattice matrix for POSCAR export`)
  }

  // Count atoms by element
  const element_counts = new Map<string, number>()
  const element_symbols: string[] = []

  for (const site of structure.sites) {
    let element_symbol = `X` // default fallback
    if (
      site.species &&
      Array.isArray(site.species) &&
      site.species.length > 0
    ) {
      const first_species = site.species[0]
      if (
        first_species && `element` in first_species && first_species.element
      ) {
        element_symbol = first_species.element
      }
    }

    if (!element_counts.has(element_symbol)) {
      element_counts.set(element_symbol, 0)
      element_symbols.push(element_symbol)
    }
    element_counts.set(element_symbol, Number(element_counts.get(element_symbol)) + 1)
  }

  // Element symbols line
  lines.push(element_symbols.join(` `))

  // Atom counts line
  lines.push(element_symbols.map((el) => element_counts.get(el)).join(` `))

  // Check if any site has selective dynamics
  const has_selective_dynamics = structure.sites.some(
    (site) => site.properties?.selective_dynamics,
  )
  if (has_selective_dynamics) {
    lines.push(`Selective dynamics`)
  }

  // Coordinate mode (Direct = fractional coordinates)
  lines.push(`Direct`)

  // Atom coordinates grouped by element
  for (const element_symbol of element_symbols) {
    for (const site of structure.sites) {
      let site_element = `X`
      if (
        site.species &&
        Array.isArray(site.species) &&
        site.species.length > 0
      ) {
        const first_species = site.species[0]
        if (
          first_species && `element` in first_species && first_species.element
        ) {
          site_element = first_species.element
        }
      }

      if (site_element === element_symbol) {
        // Get fractional coordinates
        let frac_coords: number[]
        if (site.abc && Array.isArray(site.abc) && site.abc.length >= 3) {
          frac_coords = site.abc.slice(0, 3)
        } else if (
          site.xyz &&
          Array.isArray(site.xyz) &&
          site.xyz.length >= 3 &&
          lattice.matrix &&
          Array.isArray(lattice.matrix)
        ) {
          // Convert cartesian to fractional coordinates
          const lattice_transposed = math.transpose_3x3_matrix(lattice.matrix)
          const lattice_inv = math.matrix_inverse_3x3(lattice_transposed)
          frac_coords = math.mat3x3_vec3_multiply(
            lattice_inv,
            site.xyz.slice(0, 3) as Vec3,
          )
        } else {
          throw new Error(`No valid coordinates found for site`)
        }

        let selective_dynamics_str = ``
        if (has_selective_dynamics) {
          const sd = (site.properties?.selective_dynamics ?? [
            true,
            true,
            true,
          ]) as boolean[]
          selective_dynamics_str = ` ${sd[0] ? `T` : `F`} ${sd[1] ? `T` : `F`} ${
            sd[2] ? `T` : `F`
          }`
        }

        lines.push(
          `${frac_coords[0].toFixed(8)} ${frac_coords[1].toFixed(8)} ${
            frac_coords[2].toFixed(8)
          }${selective_dynamics_str}`,
        )
      }
    }
  }

  return lines.join(`\n`)
}

// Generate JSON content string without saving
export function structure_to_json_str(structure?: AnyStructure): string {
  if (!structure) throw new Error(`No structure to export`)
  return JSON.stringify(structure, null, 2)
}

// Export structure as CIF format
export function export_structure_as_cif(structure?: AnyStructure): void {
  try {
    const content = structure_to_cif_str(structure)
    const filename = create_structure_filename(structure, `cif`)
    download(content, filename, `chemical/x-cif`)
  } catch (error) {
    console.error(`Failed to export CIF:`, error)
  }
}

// Export structure as VASP POSCAR format
export function export_structure_as_poscar(structure?: AnyStructure): void {
  try {
    const content = structure_to_poscar_str(structure)
    const filename = create_structure_filename(structure, `poscar`)
    download(content, filename, `text/plain`)
  } catch (error) {
    console.error(`Failed to export POSCAR:`, error)
  }
}

// Export structure as XYZ format. Format specification:
// - Line 1: Number of atoms
// - Line 2: Comment line (structure ID, formula, etc.)
// - Remaining lines: Element symbol followed by x, y, z coordinates (in Angstroms)
export function export_structure_as_xyz(structure?: AnyStructure): void {
  try {
    const xyz_content = structure_to_xyz_str(structure)
    const filename = create_structure_filename(structure, `xyz`)
    download(xyz_content, filename, `text/plain`)
  } catch (error) {
    console.error(`Error exporting XYZ:`, error)
  }
}

// Export structure in pymatgen JSON format
export function export_structure_as_json(structure?: AnyStructure): void {
  try {
    const data = structure_to_json_str(structure)
    const filename = create_structure_filename(structure, `json`)
    download(data, filename, `application/json`)
  } catch (error) {
    console.error(`Error exporting JSON:`, error)
  }
}
