# This file is automatically generated by pyo3_stub_gen
from collections.abc import Sequence
from typing import final

@final
class CellFireState:
    r"""
    CellFIRE optimizer state (optimizes both positions and cell).
    """
    @property
    def positions(self) -> list[list[float]]:
        r"""
        Get positions.
        """
    @property
    def cell(self) -> list[list[float]]:
        r"""
        Get cell matrix.
        """
    @property
    def num_atoms(self) -> int:
        r"""
        Number of atoms.
        """
    def __new__(
        cls,
        positions: Sequence[Sequence[float]],
        cell: Sequence[Sequence[float]],
        config: FireConfig | None = None,
        cell_factor: float = 1.0,
    ) -> CellFireState:
        r"""
        Create a new CellFIRE state.

        Args:
            positions: List of [x, y, z] positions in Angstrom
            cell: 3x3 cell matrix (row vectors)
            config: Optional FIRE configuration
            cell_factor: Scaling factor for cell DOF (default: 1.0)
        """
    def max_force(self) -> float:
        r"""
        Get maximum force component.
        """
    def max_stress(self) -> float:
        r"""
        Get maximum stress component.
        """
    def is_converged(self, f_max: float, s_max: float) -> bool:
        r"""
        Check if optimization has converged.
        """
    def step(
        self, forces: Sequence[Sequence[float]], stress: Sequence[Sequence[float]]
    ) -> None:
        r"""
        Perform one CellFIRE step with provided forces and stress.
        """

@final
class FireConfig:
    r"""
    FIRE optimizer configuration.
    """
    @property
    def dt_start(self) -> float: ...
    @dt_start.setter
    def dt_start(self, value: float) -> None: ...
    @property
    def dt_max(self) -> float: ...
    @dt_max.setter
    def dt_max(self, value: float) -> None: ...
    @property
    def n_min(self) -> int: ...
    @n_min.setter
    def n_min(self, value: int) -> None: ...
    @property
    def max_step(self) -> float: ...
    @max_step.setter
    def max_step(self, value: float) -> None: ...
    def __new__(
        cls,
        dt_start: float | None = None,
        dt_max: float | None = None,
        n_min: int | None = None,
        max_step: float | None = None,
    ) -> FireConfig:
        r"""
        Create a new FIRE configuration with default parameters.
        """

@final
class FireState:
    r"""
    FIRE optimizer state.
    """
    @property
    def positions(self) -> list[list[float]]:
        r"""
        Get positions.
        """
    @property
    def velocities(self) -> list[list[float]]:
        r"""
        Get velocities.
        """
    @property
    def num_atoms(self) -> int:
        r"""
        Number of atoms.
        """
    @property
    def dt(self) -> float:
        r"""
        Current timestep.
        """
    def __new__(
        cls, positions: Sequence[Sequence[float]], config: FireConfig | None = None
    ) -> FireState:
        r"""
        Create a new FIRE state.

        Args:
            positions: List of [x, y, z] positions in Angstrom
            config: Optional FIRE configuration
        """
    def max_force(self) -> float:
        r"""
        Get maximum force component.
        """
    def is_converged(self, f_max: float) -> bool:
        r"""
        Check if optimization has converged.
        """
    def step(self, forces: Sequence[Sequence[float]]) -> None:
        r"""
        Perform one FIRE step with provided forces.
        """
