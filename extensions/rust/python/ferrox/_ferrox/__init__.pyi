# This file is automatically generated by pyo3_stub_gen
from collections.abc import Mapping, Sequence
from typing import Any, final

@final
class Element:
    r"""
    Python wrapper for Element.

    Provides access to element properties like atomic number, mass, electronegativity,
    oxidation states, radii, and physical properties.
    """
    @property
    def symbol(self) -> str:
        r"""
        Element symbol (e.g., "Fe", "O").
        """
    @property
    def z(self) -> int:
        r"""
        Alias for atomic_number for pymatgen compatibility.
        """
    @property
    def atomic_number(self) -> int:
        r"""
        Atomic number (1-118 for real elements, 119+ for pseudo-elements).
        """
    @property
    def atomic_mass(self) -> float:
        r"""
        Atomic mass in atomic mass units (u).
        """
    @property
    def name(self) -> str:
        r"""
        Full element name (e.g., "Iron", "Oxygen").
        """
    @property
    def electronegativity(self) -> float | None:
        r"""
        Pauling electronegativity (None for noble gases, transactinides).
        """
    @property
    def row(self) -> int:
        r"""
        Periodic table row (1-7).
        """
    @property
    def period(self) -> int:
        r"""
        Periodic table period (alias for row).
        """
    @property
    def group(self) -> int:
        r"""
        Periodic table group (1-18).
        """
    @property
    def block(self) -> str:
        r"""
        Periodic table block ("S", "P", "D", or "F").
        """
    @property
    def atomic_radius(self) -> float | None:
        r"""
        Atomic radius in Angstroms.
        """
    @property
    def covalent_radius(self) -> float | None:
        r"""
        Covalent radius in Angstroms.
        """
    @property
    def oxidation_states(self) -> list[int]:
        r"""
        All known oxidation states.
        """
    @property
    def common_oxidation_states(self) -> list[int]:
        r"""
        Common oxidation states.
        """
    @property
    def icsd_oxidation_states(self) -> list[int]:
        r"""
        ICSD oxidation states (with >= 10 instances in ICSD).
        """
    @property
    def max_oxidation_state(self) -> int | None:
        r"""
        Maximum oxidation state.
        """
    @property
    def min_oxidation_state(self) -> int | None:
        r"""
        Minimum oxidation state.
        """
    @property
    def ionic_radii(self) -> dict[str, Any] | None:
        r"""
        All ionic radii as dict mapping oxidation state (str) to radius (float).
        """
    @property
    def shannon_radii(self) -> dict[str, Any] | None:
        r"""
        Full Shannon radii data structure.
        """
    @property
    def melting_point(self) -> float | None:
        r"""
        Melting point in Kelvin.
        """
    @property
    def boiling_point(self) -> float | None:
        r"""
        Boiling point in Kelvin.
        """
    @property
    def density(self) -> float | None:
        r"""
        Density in g/cm³.
        """
    @property
    def electron_affinity(self) -> float | None:
        r"""
        Electron affinity in kJ/mol.
        """
    @property
    def first_ionization_energy(self) -> float | None:
        r"""
        First ionization energy in kJ/mol.
        """
    @property
    def ionization_energies(self) -> list[float]:
        r"""
        All ionization energies in kJ/mol.
        """
    @property
    def molar_heat(self) -> float | None:
        r"""
        Molar heat capacity (Cp) in J/(mol·K).
        """
    @property
    def specific_heat(self) -> float | None:
        r"""
        Specific heat capacity in J/(g·K).
        """
    @property
    def n_valence(self) -> int | None:
        r"""
        Number of valence electrons.
        """
    @property
    def electron_configuration(self) -> str | None:
        r"""
        Electron configuration.
        """
    @property
    def electron_configuration_semantic(self) -> str | None:
        r"""
        Semantic electron configuration with noble gas core.
        """
    def __new__(cls, symbol_or_z: Any) -> Element:
        r"""
        Create an Element from symbol or atomic number.

        Args:
            symbol_or_z: Element symbol (str like "Fe") or atomic number (int like 26)

        Returns:
            Element object

        Raises:
            ValueError: If the symbol or atomic number is invalid
        """
    def ionic_radius(self, oxidation_state: int) -> float | None:
        r"""
        Ionic radius for a specific oxidation state (Angstroms).
        """
    def shannon_ionic_radius(
        self, oxidation_state: int, coordination: str, spin: str = ""
    ) -> float | None:
        r"""
        Shannon ionic radius for specific oxidation state, coordination, and spin.
        """
    def is_noble_gas(self) -> bool:
        r"""
        True if element is a noble gas.
        """
    def is_alkali(self) -> bool:
        r"""
        True if element is an alkali metal.
        """
    def is_alkaline(self) -> bool:
        r"""
        True if element is an alkaline earth metal.
        """
    def is_halogen(self) -> bool:
        r"""
        True if element is a halogen.
        """
    def is_chalcogen(self) -> bool:
        r"""
        True if element is a chalcogen.
        """
    def is_lanthanoid(self) -> bool:
        r"""
        True if element is a lanthanoid.
        """
    def is_actinoid(self) -> bool:
        r"""
        True if element is an actinoid.
        """
    def is_transition_metal(self) -> bool:
        r"""
        True if element is a transition metal.
        """
    def is_post_transition_metal(self) -> bool:
        r"""
        True if element is a post-transition metal.
        """
    def is_metalloid(self) -> bool:
        r"""
        True if element is a metalloid.
        """
    def is_metal(self) -> bool:
        r"""
        True if element is a metal.
        """
    def is_radioactive(self) -> bool:
        r"""
        True if element is radioactive.
        """
    def is_rare_earth(self) -> bool:
        r"""
        True if element is a rare earth.
        """
    def is_pseudo(self) -> bool:
        r"""
        True if element is a pseudo-element.
        """
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

@final
class LangevinIntegrator:
    r"""
    Python wrapper for Langevin integrator.
    """
    def __new__(
        cls, temperature_k: float, friction: float, dt: float, seed: int | None = None
    ) -> LangevinIntegrator:
        r"""
        Create a new Langevin integrator.

        Args:
            temperature_k: Target temperature in Kelvin (must be non-negative)
            friction: Friction coefficient in 1/fs (must be positive, typical: 0.001 to 0.01)
            dt: Time step in fs (must be positive)
            seed: Optional random seed for reproducibility
        """
    def step(self, state: MDState, compute_forces: Any) -> None:
        r"""
        Perform one Langevin dynamics step.

        Raises:
            RuntimeError: If force computation fails. State is restored to its
                original value before the step when this happens.
        """
    def set_temperature(self, temperature_k: float) -> None:
        r"""
        Set target temperature.
        """
    def set_friction(self, friction: float) -> None:
        r"""
        Set friction coefficient.
        """
    def set_dt(self, dt: float) -> None:
        r"""
        Set time step.
        """

@final
class MDState:
    r"""
    Python wrapper for MD state.
    """
    @property
    def positions(self) -> list[list[float]]:
        r"""
        Get positions as Nx3 array.
        """
    @positions.setter
    def positions(self, value: list[list[float]]) -> None:
        r"""
        Set positions from Nx3 array.
        """
    @property
    def velocities(self) -> list[list[float]]:
        r"""
        Get velocities as Nx3 array.
        """
    @velocities.setter
    def velocities(self, value: list[list[float]]) -> None:
        r"""
        Set velocities from Nx3 array.
        """
    @property
    def forces(self) -> list[list[float]]:
        r"""
        Get forces as Nx3 array.
        """
    @forces.setter
    def forces(self, value: list[list[float]]) -> None:
        r"""
        Set forces from Nx3 array.
        """
    def __new__(
        cls,
        positions: Sequence[Sequence[float]],
        masses: Sequence[float],
        velocities: Sequence[Sequence[float]] | None = None,
    ) -> MDState:
        r"""
        Create a new MD state.

        Args:
            positions: Nx3 array of atomic positions in Angstrom
            masses: N-element array of atomic masses in amu
            velocities: Optional Nx3 array of velocities (default: zeros)
        """
    def init_velocities(self, temperature_k: float, seed: int | None = None) -> None:
        r"""
        Initialize velocities from Maxwell-Boltzmann distribution.
        """
    def kinetic_energy(self) -> float:
        r"""
        Get kinetic energy in eV.
        """
    def temperature(self) -> float:
        r"""
        Get temperature in Kelvin.
        """
    def num_atoms(self) -> int:
        r"""
        Get number of atoms.
        """

@final
class NPTState:
    r"""
    State for NPT molecular dynamics.
    """
    @property
    def positions(self) -> list[list[float]]: ...
    @property
    def cell(self) -> list[list[float]]: ...
    def __new__(
        cls,
        positions: Sequence[Sequence[float]],
        masses: Sequence[float],
        cell: Sequence[Sequence[float]],
        pbc: Sequence[bool] | None = None,
    ) -> NPTState:
        r"""
        Create a new NPT state.
        """

@final
class NoseHooverChain:
    r"""
    Nosé-Hoover chain thermostat for NVT molecular dynamics.
    """
    def __new__(
        cls, target_temp: float, tau: float, dt: float, n_dof: int
    ) -> NoseHooverChain:
        r"""
        Create a new Nosé-Hoover chain thermostat.

        Args:
            target_temp: Target temperature in Kelvin (must be positive)
            tau: Coupling time constant in fs (must be positive)
            dt: Time step in fs (must be positive)
            n_dof: Number of degrees of freedom (must be positive)
        """
    def step(self, state: MDState, compute_forces: Any) -> None:
        r"""
        Perform one NVT step.
        """
    def set_temperature(self, target_temp: float) -> None:
        r"""
        Set target temperature.
        """

@final
class Species:
    r"""
    A chemical species with optional oxidation state.
    """
    @property
    def symbol(self) -> str:
        r"""
        Element symbol.
        """
    @property
    def atomic_number(self) -> int:
        r"""
        Atomic number.
        """
    @property
    def oxidation_state(self) -> int | None:
        r"""
        Oxidation state (None if neutral/unknown).
        """
    @property
    def ionic_radius(self) -> float | None:
        r"""
        Ionic radius in Angstroms (if available).
        """
    @property
    def atomic_radius(self) -> float | None:
        r"""
        Atomic radius in Angstroms (if available).
        """
    @property
    def electronegativity(self) -> float | None:
        r"""
        Electronegativity (Pauling scale, if available).
        """
    @property
    def covalent_radius(self) -> float | None:
        r"""
        Covalent radius in Angstroms (if available).
        """
    @property
    def name(self) -> str:
        r"""
        Element name.
        """
    @property
    def atomic_mass(self) -> float:
        r"""
        Atomic mass in amu.
        """
    def __new__(cls, species_str: str) -> Species:
        r"""
        Create a new Species from a string like "Fe", "Fe2+", "O2-".
        """
    def shannon_ionic_radius(self, coordination: str, spin: str = "") -> float | None:
        r"""
        Get Shannon ionic radius for specific coordination and spin.
        """

@final
class StructureMatcher:
    r"""
    Python wrapper for StructureMatcher.
    """
    @property
    def latt_len_tol(self) -> float: ...
    @property
    def site_pos_tol(self) -> float: ...
    @property
    def angle_tol(self) -> float: ...
    @property
    def primitive_cell(self) -> bool: ...
    @property
    def scale(self) -> bool: ...
    @property
    def attempt_supercell(self) -> bool: ...
    def __new__(
        cls,
        latt_len_tol: float = 0.2,
        site_pos_tol: float = 0.3,
        angle_tol: float = 5.0,
        primitive_cell: bool = True,
        scale: bool = True,
        attempt_supercell: bool = False,
        comparator: str = "species",
    ) -> StructureMatcher: ...
    def fit(
        self,
        struct1: str | dict[str, Any],
        struct2: str | dict[str, Any],
        skip_structure_reduction: bool = False,
    ) -> bool: ...
    def get_rms_dist(
        self, struct1: str | dict[str, Any], struct2: str | dict[str, Any]
    ) -> tuple[float, float] | None: ...
    def get_structure_distance(
        self, struct1: str | dict[str, Any], struct2: str | dict[str, Any]
    ) -> float: ...
    def fit_anonymous(
        self,
        struct1: str | dict[str, Any],
        struct2: str | dict[str, Any],
        mapping_name: str | None = None,
        mapping: Mapping[str, str] | None = None,
    ) -> bool: ...
    def get_structure_distance_anonymous_mapped(
        self,
        struct1: str | dict[str, Any],
        struct2: str | dict[str, Any],
        mapping: Mapping[str, str],
    ) -> float | None: ...
    def get_structure_distance_anonymous_predefined(
        self,
        struct1: str | dict[str, Any],
        struct2: str | dict[str, Any],
        mapping_name: str,
    ) -> float | None: ...
    def deduplicate(self, structures: Sequence[str]) -> list[int]: ...
    def group(self, structures: Sequence[str]) -> dict[int, list[int]]: ...
    def get_unique_indices(self, structures: Sequence[str]) -> list[int]: ...
    def find_matches(
        self, new_structures: Sequence[str], existing_structures: Sequence[str]
    ) -> list[int | None]: ...
    def reduce_structure(self, structure: str | dict[str, Any]) -> str: ...

@final
class VelocityRescale:
    r"""
    Velocity rescaling (Bussi) thermostat for NVT molecular dynamics.
    """
    def __new__(
        cls,
        target_temp: float,
        tau: float,
        dt: float,
        n_dof: int,
        seed: int | None = None,
    ) -> VelocityRescale:
        r"""
        Create a new velocity rescaling thermostat.

        Args:
            target_temp: Target temperature in Kelvin (must be positive)
            tau: Coupling time constant in fs (must be positive)
            dt: Time step in fs (must be positive)
            n_dof: Number of degrees of freedom (must be positive)
            seed: Optional random seed for reproducibility
        """
    def step(self, state: MDState, compute_forces: Any) -> None:
        r"""
        Perform one NVT step.
        """
    def set_temperature(self, target_temp: float) -> None:
        r"""
        Set target temperature.
        """

def add_charges_from_oxi_state_guesses(
    structure: str | dict[str, Any],
) -> dict[str, Any]:
    r"""
    Add oxidation states from guesses to a structure.
    """

def add_oxidation_state_by_element(
    structure: str | dict[str, Any], oxi_states: Mapping[str, int]
) -> dict[str, Any]:
    r"""
    Add oxidation states by element.
    """

def add_oxidation_state_by_site(
    structure: str | dict[str, Any], oxi_states: Sequence[int]
) -> dict[str, Any]:
    r"""
    Add oxidation states by site.
    """

def apply_inversion(
    structure: str | dict[str, Any], fractional: bool = True
) -> dict[str, Any]:
    r"""
    Apply inversion through the origin.
    """

def apply_operation(
    structure: str | dict[str, Any],
    rotation: Sequence[Sequence[float]],
    translation: Sequence[float],
    fractional: bool = True,
) -> dict[str, Any]:
    r"""
    Apply a symmetry operation (rotation + translation) to a structure.
    """

def apply_strain(
    cell: Sequence[Sequence[float]], strain: Sequence[Sequence[float]]
) -> list[list[float]]:
    r"""
    Apply a strain to a cell matrix.
    """

def apply_translation(
    structure: str | dict[str, Any],
    translation: Sequence[float],
    fractional: bool = True,
) -> dict[str, Any]:
    r"""
    Apply a translation to all sites.
    """

def area(slab: str | dict[str, Any]) -> float:
    r"""
    Get the surface area of a slab.
    """

def bulk_modulus(tensor: Sequence[Sequence[float]]) -> float:
    r"""
    Calculate the bulk modulus from elastic tensor.
    """

def calculate_energy(
    slab_energy: float, bulk_energy_per_atom: float, n_atoms: int, surface_area: float
) -> float:
    r"""
    Calculate surface energy.
    """

def classify_all_atoms(
    structure: str | dict[str, Any], cutoff: float, tolerance: float = 0.1
) -> list[str]:
    r"""
    Classify all atoms in a structure.
    """

def classify_local_structure(q4: float, q6: float, tolerance: float = 0.1) -> str:
    r"""
    Classify local structure based on Q4 and Q6 values.
    """

def classify_site(coordination: int) -> str:
    r"""
    Classify an interstitial site based on its coordination number.
    """

def composition_charge(formula: str) -> int | None:
    r"""
    Get the total charge of a composition.
    """

def compositions_almost_equal(
    formula1: str, formula2: str, rel_tol: float = 1e-06, abs_tol: float = 1e-08
) -> bool:
    r"""
    Check if two compositions are almost equal.
    """

def compute_all_element_rdfs(
    structure: str | dict[str, Any],
    r_max: float = 15.0,
    n_bins: int = 75,
    normalize: bool = True,
    auto_expand: bool = True,
    expansion_factor: float = 2.0,
) -> dict[str, Any]:
    r"""
    Compute RDFs for all element pairs. Returns dict keyed by element pair.
    """

def compute_bv_sums(
    structure: str | dict[str, Any], max_radius: float = 4.0, scale_factor: float = 1.0
) -> list[float]:
    r"""
    Compute bond valence sums.
    """

def compute_element_rdf(
    structure: str | dict[str, Any],
    element1: str,
    element2: str,
    r_max: float = 15.0,
    n_bins: int = 75,
    normalize: bool = True,
    auto_expand: bool = True,
    expansion_factor: float = 2.0,
) -> tuple[list[float], list[float]]:
    r"""
    Compute the element-specific RDF. Returns (radii, g_of_r) tuple.
    """

def compute_harmonic_bonds(
    positions: Sequence[Sequence[float]],
    bonds: Sequence[Sequence[float]],
    cell: Sequence[Sequence[float]] | None = None,
    pbc: Sequence[bool] | None = None,
    compute_stress: bool = False,
) -> tuple[float, list[list[float]], list[list[float]] | None]:
    r"""
    Compute harmonic bond energy and forces.
    V = 0.5 * k * (r - r0)^2
    """

def compute_lennard_jones(
    positions: Sequence[Sequence[float]],
    cell: Sequence[Sequence[float]] | None = None,
    pbc: Sequence[bool] | None = None,
    sigma: float = 3.4,
    epsilon: float = 0.0103,
    cutoff: float | None = None,
) -> tuple[float, list[list[float]]]:
    r"""
    Compute Lennard-Jones energy and forces.
    """

def compute_lennard_jones_forces(
    positions: Sequence[Sequence[float]],
    cell: Sequence[Sequence[float]] | None = None,
    pbc: Sequence[bool] | None = None,
    sigma: float = 3.4,
    epsilon: float = 0.0103,
    cutoff: float | None = None,
) -> list[list[float]]:
    r"""
    Compute Lennard-Jones forces only.

    Note: Energy is still computed internally but discarded. If you need both
    energy and forces, use `compute_lennard_jones` instead.
    """

def compute_morse(
    positions: Sequence[Sequence[float]],
    cell: Sequence[Sequence[float]] | None = None,
    pbc: Sequence[bool] | None = None,
    d: float = 1.0,
    alpha: float = 1.0,
    r0: float = 1.0,
    cutoff: float = 10.0,
    compute_stress: bool = False,
) -> tuple[float, list[list[float]], list[list[float]] | None]:
    r"""
    Compute Morse potential energy and forces.
    V(r) = D * (1 - exp(-alpha*(r - r0)))^2 - D
    """

def compute_rdf(
    structure: str | dict[str, Any],
    r_max: float = 15.0,
    n_bins: int = 75,
    normalize: bool = True,
    auto_expand: bool = True,
    expansion_factor: float = 2.0,
) -> tuple[list[float], list[float]]:
    r"""
    Compute the radial distribution function.
    """

def compute_soft_sphere(
    positions: Sequence[Sequence[float]],
    cell: Sequence[Sequence[float]] | None = None,
    pbc: Sequence[bool] | None = None,
    sigma: float = 1.0,
    epsilon: float = 1.0,
    alpha: float = 12.0,
    cutoff: float = 10.0,
    compute_stress: bool = False,
) -> tuple[float, list[list[float]], list[list[float]] | None]:
    r"""
    Compute Soft Sphere potential energy and forces.
    V(r) = epsilon * (sigma/r)^alpha
    """

def compute_steinhardt_q(
    structure: str | dict[str, Any], deg: int, cutoff: float
) -> list[float]:
    r"""
    Compute Steinhardt Q order parameter for all atoms.
    """

def compute_wulff(
    structure: str | dict[str, Any],
    surface_energies: Sequence[tuple[Sequence[int], float]],
) -> dict[str, Any]:
    r"""
    Compute the Wulff shape from surface energies.
    """

def compute_xrd(
    structure: str | dict[str, Any],
    two_theta_range: tuple[float, float] | None = None,
    wavelength: float = 1.5406,
) -> dict[str, Any]:
    r"""
    Compute X-ray diffraction pattern.
    """

def copy_structure(structure: str | dict[str, Any]) -> dict[str, Any]:
    r"""
    Copy a structure.
    """

def create_antisite(
    structure: str | dict[str, Any], site_a_idx: int, site_b_idx: int
) -> dict[str, Any]:
    r"""
    Create an antisite pair by swapping species at two sites.
    Returns structure dict (no defect metadata since antisites modify two sites).
    """

def create_dimer(
    structure: str | dict[str, Any],
    site_a_idx: int,
    site_b_idx: int,
    target_distance: float,
) -> dict[str, Any]:
    r"""
    Create a dimer by moving two atoms closer together.
    """

def create_interstitial(
    structure: str | dict[str, Any], position: Sequence[float], species: str
) -> dict[str, Any]:
    r"""
    Create an interstitial by adding an atom at a fractional position.
    """

def create_substitution(
    structure: str | dict[str, Any], site_idx: int, new_species: str
) -> dict[str, Any]:
    r"""
    Create a substitutional defect by replacing the species at a site.
    """

def create_vacancy(structure: str | dict[str, Any], site_idx: int) -> dict[str, Any]:
    r"""
    Create a vacancy by removing an atom at the specified site index.
    """

def d_spacing(structure: str | dict[str, Any], h: int, k: int, l: int) -> float:
    r"""
    Calculate d-spacing for a Miller index.
    """

def deform(
    structure: str | dict[str, Any], gradient: Sequence[Sequence[float]]
) -> dict[str, Any]:
    r"""
    Apply a deformation gradient to the structure.
    """

def delaunay_reduce(structure: str | dict[str, Any]) -> dict[str, Any]:
    r"""
    Perform Delaunay reduction on the lattice (uses LLL).
    """

def diffusion_from_msd(
    msd: Sequence[float],
    times: Sequence[float],
    dim: int = 3,
    start_fraction: float = 0.2,
    end_fraction: float = 0.8,
) -> tuple[float, float]:
    r"""
    Calculate diffusion coefficient from mean squared displacement.
    """

def diffusion_from_vacf(vacf: Sequence[float], dt: float, dim: int = 3) -> float:
    r"""
    Calculate diffusion coefficient from velocity autocorrelation function.
    """

def distance_from_point(
    structure: str | dict[str, Any], idx: int, point: Sequence[float]
) -> float:
    r"""
    Get the distance from a site to a point.
    """

def distance_matrix(structure: str | dict[str, Any]) -> list[list[float]]:
    r"""
    Get the distance matrix.
    """

def distort_bonds(
    structure: str | dict[str, Any],
    center_site_idx: int,
    distortion_factors: Sequence[float],
    num_neighbors: int | None = None,
    cutoff: float = 5.0,
) -> list[Any]:
    r"""
    Distort bonds around a defect site by specified factors.
    """

def enumerate_derivatives(
    structure: str | dict[str, Any], min_size: int = 1, max_size: int = 4
) -> list[dict[str, Any]]:
    r"""
    Enumerate derivative structures within a size range.
    """

def enumerate_miller(max_index: int) -> list[list[int]]:
    r"""
    Enumerate Miller indices up to a maximum value.
    """

def enumerate_terminations(
    structure: str | dict[str, Any],
    h: int,
    k: int,
    l: int,
    min_slab: float = 10.0,
    min_vacuum: float = 10.0,
    symprec: float = 0.01,
) -> list[dict[str, Any]]:
    r"""
    Enumerate terminations for a given Miller index.
    """

def ewald_energy(
    structure: str | dict[str, Any],
    eta: float | None = None,
    real_cutoff: float | None = None,
    accuracy: float | None = None,
) -> float:
    r"""
    Compute Ewald energy for a structure with oxidation states.
    """

def find_adsorption_sites(
    slab: str | dict[str, Any],
    height: float = 2.0,
    site_types: Sequence[str] | None = None,
    neighbor_cutoff: float | None = None,
    surface_tolerance: float | None = None,
) -> list[dict[str, Any]]:
    r"""
    Find adsorption sites on a slab.
    """

def find_interstitial_sites(
    structure: str | dict[str, Any],
    min_dist: float | None = None,
    symprec: float = 0.01,
) -> list[dict[str, Any]]:
    r"""
    Find potential interstitial sites using Voronoi tessellation.
    """

def find_supercell(
    structure: str | dict[str, Any],
    min_image_dist: float = 10.0,
    max_atoms: int = 200,
    cubic: bool = False,
) -> list[list[int]]:
    r"""
    Find an optimal supercell matrix for dilute defect calculations.
    """

def find_supercell_matrix(
    structure: str | dict[str, Any], target_atoms: int = 100
) -> list[list[int]]:
    r"""
    Find the supercell matrix for a target number of atoms.
    """

def find_voronoi_interstitials(
    structure: str | dict[str, Any],
    min_dist: float | None = None,
    symprec: float = 0.01,
) -> list[Any]:
    r"""
    Find Voronoi-based interstitial sites.
    """

def formula_hash(formula: str) -> int:
    r"""
    Get a hash of a formula (for fast comparisons).
    """

def fractional_composition(formula: str) -> dict[str, Any]:
    r"""
    Get the fractional composition.
    """

def from_ase_atoms(atoms: Any) -> dict[str, Any]:
    r"""
    Convert an ASE Atoms object directly to ferrox dict format.
    """

def from_pymatgen_structure(structure: Any) -> dict[str, Any]:
    r"""
    Convert a pymatgen Structure or Molecule directly to ferrox dict format.

    Handles both periodic structures (with lattice) and non-periodic molecules.
    Detection is automatic based on whether the object has a `lattice` attribute.
    """

def from_torch_sim_state(state_dict: dict[str, Any]) -> list[dict[str, Any]]:
    r"""
    Parse a TorchSim SimState dict to a list of Structure dicts.

    Converts a batched state back to individual structures.
    """

def generate_all(
    structure: str | dict[str, Any],
    extrinsic: Sequence[str] | None = None,
    symprec: float = 0.01,
    interstitial_min_dist: float = 1.0,
) -> dict[str, Any]:
    r"""
    Generate all point defects for a structure.
    """

def generate_slabs(
    structure: str | dict[str, Any],
    miller_index: Sequence[int],
    min_slab_size: float = 10.0,
    min_vacuum_size: float = 10.0,
    center_slab: bool = True,
    in_unit_planes: bool = False,
    symprec: float = 0.01,
) -> list[dict[str, Any]]:
    r"""
    Generate all slabs for a given Miller index (all terminations).
    """

def generate_strains(
    magnitude: float = 0.01, shear: bool = True
) -> list[list[list[float]]]:
    r"""
    Generate strain matrices for elastic constant calculation.
    """

def get_all_site_properties(structure: str | dict[str, Any]) -> list[Any]:
    r"""
    Get all site properties for a structure.
    """

def get_atomic_fraction(formula: str, element: str) -> float:
    r"""
    Get the atomic fraction of an element.
    """

def get_atomic_scattering_params() -> dict[str, Any]:
    r"""
    Get atomic scattering parameters for all elements.
    Returns a dict of element -> [[a1,b1], [a2,b2], [a3,b3], [a4,b4]] coefficients.
    """

def get_cn_voronoi(
    structure: str | dict[str, Any], site_idx: int, min_solid_angle: float = 0.1
) -> float:
    r"""
    Get coordination number using Voronoi tessellation.
    """

def get_cn_voronoi_all(
    structure: str | dict[str, Any], min_solid_angle: float = 0.1
) -> list[float]:
    r"""
    Get Voronoi coordination numbers for all sites.
    """

def get_conventional(
    structure: str | dict[str, Any], symprec: float = 0.01
) -> dict[str, Any]:
    r"""
    Get the conventional cell.
    """

def get_coordination_number(
    structure: str | dict[str, Any], site_idx: int, cutoff: float
) -> int:
    r"""
    Get the coordination number for a single site.
    """

def get_coordination_numbers(
    structure: str | dict[str, Any], cutoff: float
) -> list[int]:
    r"""
    Get coordination numbers for all sites.
    """

def get_crystal_system(structure: str | dict[str, Any], symprec: float = 0.01) -> str:
    r"""
    Get the crystal system.
    """

def get_density(structure: str | dict[str, Any]) -> float | None:
    r"""
    Get the density of a structure in g/cm^3.

    Returns None for non-periodic or zero-volume structures.
    """

def get_distance(structure: str | dict[str, Any], idx_a: int, idx_b: int) -> float:
    r"""
    Get the distance between two sites.
    """

def get_distance_and_image(
    structure: str | dict[str, Any], idx_a: int, idx_b: int
) -> tuple[float, list[int]]:
    r"""
    Get the distance and periodic image between two sites.
    """

def get_distance_with_image(
    structure: str | dict[str, Any], idx1: int, idx2: int, jimage: Sequence[int]
) -> float:
    r"""
    Get distance between two sites with a specific periodic image.
    """

def get_equivalent_sites(
    structure: str | dict[str, Any], symprec: float = 0.01
) -> list[int]:
    r"""
    Get equivalent sites.
    """

def get_hall_number(structure: str | dict[str, Any], symprec: float = 0.01) -> int:
    r"""
    Get the Hall number.
    """

def get_inv_matrix(structure: str | dict[str, Any]) -> list[list[float]]:
    r"""
    Get the inverse lattice matrix.
    """

def get_lll_mapping(structure: str | dict[str, Any]) -> list[list[float]]:
    r"""
    Get the LLL reduction mapping matrix.
    """

def get_lll_reduced_lattice(
    structure: str | dict[str, Any], delta: float = 0.75
) -> list[list[float]]:
    r"""
    Get the LLL-reduced lattice.
    """

def get_local_environment(
    structure: str | dict[str, Any], site_idx: int, cutoff: float
) -> list[dict[str, Any]]:
    r"""
    Get the local environment for a site.
    """

def get_local_environment_voronoi(
    structure: str | dict[str, Any], site_idx: int, min_solid_angle: float = 0.1
) -> list[dict[str, Any]]:
    r"""
    Get Voronoi-based local environment for a site.
    """

def get_metric_tensor(structure: str | dict[str, Any]) -> list[list[float]]:
    r"""
    Get the lattice metric tensor.
    """

def get_neighbor_list(
    structure: str | dict[str, Any], cutoff: float
) -> tuple[list[int], list[int], list[list[int]], list[float]]:
    r"""
    Get the neighbor list for a structure.
    Returns (center_indices, neighbor_indices, images, distances) as separate lists.
    """

def get_neighbors(
    structure: str | dict[str, Any], site_idx: int, cutoff: float
) -> list[dict[str, Any]]:
    r"""
    Get neighbors for a site.
    """

def get_pearson_symbol(structure: str | dict[str, Any], symprec: float = 0.01) -> str:
    r"""
    Get the Pearson symbol.
    """

def get_primitive(
    structure: str | dict[str, Any], symprec: float = 0.01
) -> dict[str, Any]:
    r"""
    Get the primitive cell.
    """

def get_reciprocal_lattice(structure: str | dict[str, Any]) -> list[list[float]]:
    r"""
    Get the reciprocal lattice matrix.
    """

def get_reduced_factor(formula: str) -> float:
    r"""
    Get the reduction factor of a formula.
    """

def get_reduced_structure(
    structure: str | dict[str, Any], algorithm: str = "niggli"
) -> dict[str, Any]:
    r"""
    Get a reduced cell structure.
    """

def get_reduced_structure_with_params(
    structure: str | dict[str, Any],
    algorithm: str = "niggli",
    niggli_tol: float = 1e-05,
    lll_delta: float = 0.75,
) -> dict[str, Any]:
    r"""
    Get structure with reduced lattice using custom parameters.
    """

def get_site_properties(structure: str | dict[str, Any], idx: int) -> dict[str, Any]:
    r"""
    Get site properties for a specific site.
    """

def get_sorted_by_electronegativity(
    structure: str | dict[str, Any], reverse: bool | None
) -> dict[str, Any]:
    r"""
    Get structure sorted by electronegativity.
    """

def get_sorted_structure(
    structure: str | dict[str, Any], reverse: bool = False
) -> dict[str, Any]:
    r"""
    Get structure sorted by species.
    """

def get_spacegroup_number(
    structure: str | dict[str, Any], symprec: float = 0.01
) -> int:
    r"""
    Get the space group number.
    """

def get_spacegroup_symbol(
    structure: str | dict[str, Any], symprec: float = 0.01
) -> str:
    r"""
    Get the space group symbol.
    """

def get_structure_metadata(structure: str | dict[str, Any]) -> dict[str, Any]:
    r"""
    Get structure metadata.
    """

def get_surface_atoms(slab: str | dict[str, Any], tolerance: float = 0.5) -> list[int]:
    r"""
    Get surface atom indices.
    """

def get_symmetry_dataset(
    structure: str | dict[str, Any], symprec: float = 0.01
) -> dict[str, Any]:
    r"""
    Get the full symmetry dataset.
    """

def get_symmetry_operations(
    structure: str | dict[str, Any], symprec: float = 0.01
) -> list[dict[str, Any]]:
    r"""
    Get symmetry operations.
    """

def get_total_mass(structure: str | dict[str, Any]) -> float:
    r"""
    Get the total mass of a structure in atomic mass units (amu).
    """

def get_volume(structure: str | dict[str, Any]) -> float:
    r"""
    Get the volume of a structure in Angstrom^3.
    """

def get_voronoi_neighbors(
    structure: str | dict[str, Any], site_idx: int, min_solid_angle: float = 0.1
) -> list[tuple[int, float]]:
    r"""
    Get Voronoi neighbors for a site.
    """

def get_wt_fraction(formula: str, element: str) -> float:
    r"""
    Get the weight fraction of an element.
    """

def get_wyckoff_letters(
    structure: str | dict[str, Any], symprec: float = 0.01
) -> list[str]:
    r"""
    Get Wyckoff letters for all sites.
    """

def guess_charge_states(defect_type: str, species: str | None = None) -> list[int]:
    r"""
    Guess reasonable charge states for a defect based on element oxidation states.

    Args:
        defect_type: Type of defect (currently unused, for future heuristics)
        species: Element symbol to look up oxidation states for

    Returns:
        List of possible charge states based on common oxidation states
    """

def guess_oxidation_states(structure: str | dict[str, Any]) -> dict[str, Any]:
    r"""
    Guess oxidation states using structure's composition.
    """

def interpolate(
    struct1: str | dict[str, Any],
    struct2: str | dict[str, Any],
    n_images: int,
    interpolate_lattices: bool = False,
    use_pbc: bool = True,
) -> list[dict[str, Any]]:
    r"""
    Interpolate between two structures.
    """

def is_charge_balanced(formula: str) -> bool | None:
    r"""
    Check if a composition is charge balanced.
    """

def is_niggli_reduced(
    structure: str | dict[str, Any], tolerance: float = 1e-05
) -> bool:
    r"""
    Check if a structure is Niggli reduced (compares against reducing it).
    """

def is_periodic_image(
    structure: str | dict[str, Any], idx_a: int, idx_b: int, tolerance: float
) -> bool:
    r"""
    Check if two sites are periodic images of each other.
    """

def is_stable(tensor: Sequence[Sequence[float]]) -> bool:
    r"""
    Check if an elastic tensor indicates mechanical stability.
    """

def is_supercell(
    structure: str | dict[str, Any],
    potential_supercell: str | dict[str, Any],
    tolerance: float = 0.01,
) -> list[list[int]] | None:
    r"""
    Check if one structure is a supercell of another, returning the transformation matrix if so.
    """

def lattices_equivalent(
    structure1: str | dict[str, Any],
    structure2: str | dict[str, Any],
    length_tol: float = 0.01,
    angle_tol: float = 1.0,
) -> bool:
    r"""
    Check if two lattices are equivalent.
    """

def local_rattle(
    structure: str | dict[str, Any],
    center_site_idx: int,
    max_amplitude: float,
    decay_radius: float,
    seed: int,
) -> dict[str, Any]:
    r"""
    Apply local rattling with distance-dependent amplitude decay.
    """

def make_slab(
    structure: str | dict[str, Any],
    miller_index: Sequence[int],
    min_slab_size: float = 10.0,
    min_vacuum_size: float = 10.0,
    center_slab: bool = True,
    in_unit_planes: bool = False,
    symprec: float = 0.01,
    termination_index: int = 0,
) -> dict[str, Any]:
    r"""
    Generate a single slab for a given Miller index and termination.
    """

def make_supercell(
    structure: str | dict[str, Any], matrix: Sequence[Sequence[int]]
) -> dict[str, Any]:
    r"""
    Create a supercell using a 3x3 transformation matrix.
    """

def make_supercell_diag(
    structure: str | dict[str, Any], scaling: Sequence[int]
) -> dict[str, Any]:
    r"""
    Create a diagonal supercell.
    """

def matches(
    struct1: str | dict[str, Any],
    struct2: str | dict[str, Any],
    anonymous: bool = False,
) -> bool:
    r"""
    Check if two structures match.
    """

def miller_to_normal(
    structure: str | dict[str, Any], miller: Sequence[int]
) -> list[float]:
    r"""
    Convert Miller index to a normal vector.
    """

def minimum_image_distance(
    structure: str | dict[str, Any], point1: Sequence[float], point2: Sequence[float]
) -> float:
    r"""
    Calculate the minimum image distance between two points (in fractional coords).
    """

def minimum_image_vector(
    structure: str | dict[str, Any], point1: Sequence[float], point2: Sequence[float]
) -> list[float]:
    r"""
    Calculate the minimum image vector (fractional delta -> cartesian vector).
    """

def molecule_to_json(molecule: str | dict[str, Any]) -> str:
    r"""
    Convert a molecule to pymatgen JSON format string.
    """

def molecule_to_xyz(molecule: str | dict[str, Any], comment: str | None = None) -> str:
    r"""
    Convert a molecule to XYZ format string.
    """

def niggli_reduce(structure: str | dict[str, Any]) -> dict[str, Any]:
    r"""
    Perform Niggli reduction on the lattice.
    """

def normalize_element_symbol(symbol: str) -> dict[str, Any]:
    r"""
    Normalize an element symbol string, extracting element, oxidation state, and metadata.
    """

def order_disordered(
    structure: str | dict[str, Any], max_structures: int = 100
) -> list[dict[str, Any]]:
    r"""
    Generate ordered structures from a disordered structure.
    """

def oxi_state_guesses(
    structure_or_formula: str, all_states: bool = False
) -> list[dict[str, Any]]:
    r"""
    Guess oxidation states for a structure or formula.
    Accepts either a structure JSON string or a formula string like "Fe2O3".
    """

def parse_ase_dict(ase_dict: dict[str, Any]) -> tuple[str, dict[str, Any]]:
    r"""
    Parse ASE Atoms dict, returning either a Structure or Molecule dict.
    """

def parse_composition(formula: str) -> dict[str, Any]:
    r"""
    Parse a composition formula and return rich metadata.
    """

def parse_molecule_json(json_str: str) -> dict[str, Any]:
    r"""
    Parse a molecule from pymatgen Molecule JSON format.
    """

def parse_poscar_file(path: str) -> dict[str, Any]:
    r"""
    Parse a structure from a POSCAR file.

    Supports VASP 5+ format with element symbols. VASP 4 format is not supported.
    """

def parse_poscar_str(content: str) -> dict[str, Any]:
    r"""
    Parse a structure from POSCAR content string.

    Supports VASP 5+ format with element symbols. VASP 4 format is not supported.
    """

def parse_structure_file(path: str) -> dict[str, Any]:
    r"""
    Parse a structure file (auto-detects format from extension).
    """

def parse_torch_sim_state_json(json_str: str) -> list[dict[str, Any]]:
    r"""
    Parse a TorchSim SimState JSON string to a list of Structure dicts.
    """

def parse_trajectory(path: str) -> list[dict[str, Any]]:
    r"""
    Parse trajectory file (extXYZ format).
    """

def parse_xyz_file(path: str) -> dict[str, Any]:
    r"""
    Parse a molecule from an XYZ file.
    """

def parse_xyz_flexible(path: str) -> tuple[str, dict[str, Any]]:
    r"""
    Parse XYZ file path flexibly, returning Structure if lattice present, Molecule otherwise.
    """

def parse_xyz_str(content: str) -> dict[str, Any]:
    r"""
    Parse a molecule from XYZ file content.
    """

def perpendicular_distances(structure: str | dict[str, Any]) -> list[float]:
    r"""
    Get perpendicular distances for each lattice direction.
    """

def perturb(
    structure: str | dict[str, Any],
    distance: float,
    min_distance: float | None = None,
    seed: int | None = None,
) -> dict[str, Any]:
    r"""
    Perturb all sites by random vectors.
    """

def poisson_ratio(bulk: float, shear: float) -> float:
    r"""
    Calculate Poisson's ratio from bulk and shear moduli.
    """

def rattle(
    structure: str | dict[str, Any],
    stdev: float,
    seed: int,
    min_distance: float = 0.5,
    max_attempts: int = 100,
) -> dict[str, Any]:
    r"""
    Apply Monte Carlo rattling to all atoms in a structure.
    """

def reduced_composition(formula: str) -> dict[str, Any]:
    r"""
    Get the reduced composition.
    """

def remap_elements(formula: str, mapping: Mapping[str, str]) -> dict[str, Any]:
    r"""
    Remap elements in a formula.
    """

def remove_oxidation_states(structure: str | dict[str, Any]) -> dict[str, Any]:
    r"""
    Remove oxidation states from a structure.
    """

def remove_sites(
    structure: str | dict[str, Any], indices: Sequence[int]
) -> dict[str, Any]:
    r"""
    Remove sites at specified indices.
    """

def remove_species(
    structure: str | dict[str, Any], species_list: Sequence[str]
) -> dict[str, Any]:
    r"""
    Remove all sites of specified species.
    """

def set_site_property(
    structure: str | dict[str, Any], idx: int, key: str, value: Any
) -> dict[str, Any]:
    r"""
    Set a site property.
    """

def shear_modulus(tensor: Sequence[Sequence[float]]) -> float:
    r"""
    Calculate the shear modulus from elastic tensor.
    """

def site_labels(structure: str | dict[str, Any]) -> list[str]:
    r"""
    Get labels for all sites.
    """

def species_hash(formula: str) -> int:
    r"""
    Get a hash based on species (including oxidation states).
    """

def species_strings(structure: str | dict[str, Any]) -> list[str]:
    r"""
    Get species strings for all sites.
    """

def strain_to_voigt(strain: Sequence[Sequence[float]]) -> list[float]:
    r"""
    Convert strain tensor to Voigt notation.
    """

def stress_to_voigt(stress: Sequence[Sequence[float]]) -> list[float]:
    r"""
    Convert stress tensor to Voigt notation.
    """

def structures_to_torch_sim_state(
    structures: Sequence[str | dict[str, Any]],
) -> dict[str, Any]:
    r"""
    Convert multiple Structures to a batched TorchSim SimState dict.

    All structures are combined into a single batched state where:
    - system_idx indicates which system each atom belongs to
    - cell contains one 3x3 matrix per system
    - charge/spin have one value per system
    """

def substitute_species(
    structure: str | dict[str, Any], old_species: str, new_species: str
) -> dict[str, Any]:
    r"""
    Substitute one species with another.
    """

def tensor_from_stresses(
    strains: Sequence[Sequence[Sequence[float]]],
    stresses: Sequence[Sequence[Sequence[float]]],
) -> list[list[float]]:
    r"""
    Calculate the elastic tensor from strains and stresses.
    """

def to_ase_atoms(structure: str | dict[str, Any]) -> Any:
    r"""
    Convert a ferrox dict to an ASE Atoms object.
    """

def to_cif(structure: str | dict[str, Any], data_name: str | None = None) -> str:
    r"""
    Convert a structure to CIF format string.
    """

def to_extxyz(structure: str | dict[str, Any]) -> str:
    r"""
    Convert a structure to extXYZ format string.
    """

def to_json(structure: str | dict[str, Any]) -> str:
    r"""
    Alias for to_pymatgen_json for convenience.
    """

def to_poscar(structure: str | dict[str, Any], comment: str | None = None) -> str:
    r"""
    Convert a structure to POSCAR format string.
    """

def to_pymatgen_json(structure: str | dict[str, Any]) -> str:
    r"""
    Convert a structure to pymatgen JSON format string.
    """

def to_pymatgen_molecule(molecule: str | dict[str, Any]) -> Any:
    r"""
    Convert a ferrox dict to a pymatgen Molecule object.
    """

def to_pymatgen_structure(structure: str | dict[str, Any]) -> Any:
    r"""
    Convert a ferrox dict to a pymatgen Structure object.
    """

def to_torch_sim_state(structure: str | dict[str, Any]) -> dict[str, Any]:
    r"""
    Convert a Structure to TorchSim SimState dict format.

    The returned dict has the same structure as torch_sim.SimState:
    - positions: list[Any] of [x, y, z] for all atoms
    - masses: list[Any] of atomic masses in amu
    - cell: list[Any] of 3x3 matrices (one per system, column-major)
    - pbc: [bool, bool, bool] periodic boundary conditions
    - atomic_numbers: list[Any] of atomic numbers
    - system_idx: list[Any] of system indices (all 0 for single structure)
    - charge: list[Any] of system charges
    - spin: list[Any] of system spins
    """

def translate_sites(
    structure: str | dict[str, Any],
    indices: Sequence[int],
    vector: Sequence[float],
    fractional: bool = True,
) -> dict[str, Any]:
    r"""
    Translate selected sites by a vector.
    """

def velocity_verlet_step(state: MDState, dt: float, compute_forces: Any) -> None:
    r"""
    Perform one velocity Verlet step (NVE ensemble).

    Args:
        state: MD state to update
        dt: Time step in fs (must be positive)
        compute_forces: Callback to compute forces

    Raises:
        ValueError: If dt is not positive and finite.
        RuntimeError: If force computation fails. State is restored to its
            original value before the step when this happens.
    """

def wrap_to_unit_cell(structure: str | dict[str, Any]) -> dict[str, Any]:
    r"""
    Wrap all sites to the unit cell.
    """

def write_structure_file(structure: str | dict[str, Any], path: str) -> None:
    r"""
    Write a structure to a file with automatic format detection.
    """

def youngs_modulus(bulk: float, shear: float) -> float:
    r"""
    Calculate Young's modulus from bulk and shear moduli.
    """

def zener_ratio(c11: float, c12: float, c44: float) -> float:
    r"""
    Calculate the Zener anisotropy ratio.
    """

__version__: str

# Namespace classes that group related functions

class Cell:
    delaunay_reduce = delaunay_reduce
    find_supercell_matrix = find_supercell_matrix
    is_niggli_reduced = is_niggli_reduced
    is_supercell = is_supercell
    lattices_equivalent = lattices_equivalent
    minimum_image_distance = minimum_image_distance
    minimum_image_vector = minimum_image_vector
    niggli_reduce = niggli_reduce
    perpendicular_distances = perpendicular_distances

class Composition:
    composition_charge = composition_charge
    compositions_almost_equal = compositions_almost_equal
    formula_hash = formula_hash
    fractional_composition = fractional_composition
    get_atomic_fraction = get_atomic_fraction
    get_reduced_factor = get_reduced_factor
    get_wt_fraction = get_wt_fraction
    is_charge_balanced = is_charge_balanced
    parse_composition = parse_composition
    reduced_composition = reduced_composition
    remap_elements = remap_elements
    species_hash = species_hash

class Coordination:
    get_cn_voronoi = get_cn_voronoi
    get_cn_voronoi_all = get_cn_voronoi_all
    get_coordination_number = get_coordination_number
    get_coordination_numbers = get_coordination_numbers
    get_local_environment = get_local_environment
    get_local_environment_voronoi = get_local_environment_voronoi
    get_neighbors = get_neighbors
    get_voronoi_neighbors = get_voronoi_neighbors

class Defects:
    classify_site = classify_site
    create_antisite = create_antisite
    create_dimer = create_dimer
    create_interstitial = create_interstitial
    create_substitution = create_substitution
    create_vacancy = create_vacancy
    distort_bonds = distort_bonds
    find_interstitial_sites = find_interstitial_sites
    find_supercell = find_supercell
    find_voronoi_interstitials = find_voronoi_interstitials
    generate_all = generate_all
    guess_charge_states = guess_charge_states
    local_rattle = local_rattle
    rattle = rattle

class Elastic:
    apply_strain = apply_strain
    bulk_modulus = bulk_modulus
    generate_strains = generate_strains
    is_stable = is_stable
    poisson_ratio = poisson_ratio
    shear_modulus = shear_modulus
    strain_to_voigt = strain_to_voigt
    stress_to_voigt = stress_to_voigt
    tensor_from_stresses = tensor_from_stresses
    youngs_modulus = youngs_modulus
    zener_ratio = zener_ratio

class Io:
    from_ase_atoms = from_ase_atoms
    from_pymatgen_structure = from_pymatgen_structure
    from_torch_sim_state = from_torch_sim_state
    molecule_to_json = molecule_to_json
    molecule_to_xyz = molecule_to_xyz
    parse_ase_dict = parse_ase_dict
    parse_molecule_json = parse_molecule_json
    parse_poscar_file = parse_poscar_file
    parse_poscar_str = parse_poscar_str
    parse_structure_file = parse_structure_file
    parse_torch_sim_state_json = parse_torch_sim_state_json
    parse_trajectory = parse_trajectory
    parse_xyz_file = parse_xyz_file
    parse_xyz_flexible = parse_xyz_flexible
    parse_xyz_str = parse_xyz_str
    structures_to_torch_sim_state = structures_to_torch_sim_state
    to_ase_atoms = to_ase_atoms
    to_cif = to_cif
    to_extxyz = to_extxyz
    to_json = to_json
    to_poscar = to_poscar
    to_pymatgen_json = to_pymatgen_json
    to_pymatgen_molecule = to_pymatgen_molecule
    to_pymatgen_structure = to_pymatgen_structure
    to_torch_sim_state = to_torch_sim_state
    write_structure_file = write_structure_file

class Lattice:
    get_inv_matrix = get_inv_matrix
    get_lll_mapping = get_lll_mapping
    get_lll_reduced_lattice = get_lll_reduced_lattice
    get_metric_tensor = get_metric_tensor
    get_reciprocal_lattice = get_reciprocal_lattice

class Md:
    LangevinIntegrator = LangevinIntegrator
    MDState = MDState
    NPTState = NPTState
    NoseHooverChain = NoseHooverChain
    VelocityRescale = VelocityRescale
    velocity_verlet_step = velocity_verlet_step

class Neighbors:
    distance_from_point = distance_from_point
    distance_matrix = distance_matrix
    get_distance = get_distance
    get_distance_and_image = get_distance_and_image
    get_neighbor_list = get_neighbor_list
    is_periodic_image = is_periodic_image

class OrderParams:
    classify_all_atoms = classify_all_atoms
    classify_local_structure = classify_local_structure
    compute_steinhardt_q = compute_steinhardt_q

class Oxidation:
    add_charges_from_oxi_state_guesses = add_charges_from_oxi_state_guesses
    add_oxidation_state_by_element = add_oxidation_state_by_element
    add_oxidation_state_by_site = add_oxidation_state_by_site
    compute_bv_sums = compute_bv_sums
    guess_oxidation_states = guess_oxidation_states
    oxi_state_guesses = oxi_state_guesses
    remove_oxidation_states = remove_oxidation_states

class Potentials:
    compute_harmonic_bonds = compute_harmonic_bonds
    compute_lennard_jones = compute_lennard_jones
    compute_lennard_jones_forces = compute_lennard_jones_forces
    compute_morse = compute_morse
    compute_soft_sphere = compute_soft_sphere

class Properties:
    get_density = get_density
    get_structure_metadata = get_structure_metadata
    get_total_mass = get_total_mass
    get_volume = get_volume

class Rdf:
    compute_all_element_rdfs = compute_all_element_rdfs
    compute_element_rdf = compute_element_rdf
    compute_rdf = compute_rdf

class SpeciesNamespace:
    Species = Species

class Structure:
    StructureMatcher = StructureMatcher
    copy_structure = copy_structure
    deform = deform
    enumerate_derivatives = enumerate_derivatives
    ewald_energy = ewald_energy
    get_all_site_properties = get_all_site_properties
    get_distance_with_image = get_distance_with_image
    get_reduced_structure = get_reduced_structure
    get_reduced_structure_with_params = get_reduced_structure_with_params
    get_site_properties = get_site_properties
    get_sorted_by_electronegativity = get_sorted_by_electronegativity
    get_sorted_structure = get_sorted_structure
    get_structure_metadata = get_structure_metadata
    interpolate = interpolate
    make_supercell = make_supercell
    make_supercell_diag = make_supercell_diag
    matches = matches
    order_disordered = order_disordered
    perturb = perturb
    remove_sites = remove_sites
    remove_species = remove_species
    set_site_property = set_site_property
    site_labels = site_labels
    species_strings = species_strings
    substitute_species = substitute_species
    translate_sites = translate_sites
    wrap_to_unit_cell = wrap_to_unit_cell

class Surfaces:
    area = area
    calculate_energy = calculate_energy
    compute_wulff = compute_wulff
    d_spacing = d_spacing
    enumerate_miller = enumerate_miller
    enumerate_terminations = enumerate_terminations
    find_adsorption_sites = find_adsorption_sites
    generate_slabs = generate_slabs
    get_surface_atoms = get_surface_atoms
    make_slab = make_slab
    miller_to_normal = miller_to_normal

class Symmetry:
    apply_inversion = apply_inversion
    apply_operation = apply_operation
    apply_translation = apply_translation
    get_conventional = get_conventional
    get_crystal_system = get_crystal_system
    get_equivalent_sites = get_equivalent_sites
    get_hall_number = get_hall_number
    get_pearson_symbol = get_pearson_symbol
    get_primitive = get_primitive
    get_spacegroup_number = get_spacegroup_number
    get_spacegroup_symbol = get_spacegroup_symbol
    get_symmetry_dataset = get_symmetry_dataset
    get_symmetry_operations = get_symmetry_operations
    get_wyckoff_letters = get_wyckoff_letters

class Trajectory:
    diffusion_from_msd = diffusion_from_msd
    diffusion_from_vacf = diffusion_from_vacf

class Xrd:
    compute_xrd = compute_xrd
    get_atomic_scattering_params = get_atomic_scattering_params

# Lowercase aliases for module-style imports
cell = Cell
composition = Composition
coordination = Coordination
defects = Defects
elastic = Elastic
io = Io
lattice = Lattice
md = Md
neighbors = Neighbors
order_params = OrderParams
oxidation = Oxidation
potentials = Potentials
properties = Properties
rdf = Rdf
species = SpeciesNamespace
structure = Structure
surfaces = Surfaces
symmetry = Symmetry
trajectory = Trajectory
xrd = Xrd
