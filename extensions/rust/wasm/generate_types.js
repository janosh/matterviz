#!/usr/bin/env node
// Auto-generate types.d.ts from wasm-pack output + Rust source.
// Reads pkg/ferrox.d.ts (generated by wasm-pack) and patches it:
// 1. Adds typed WasmResult<T> parameters by parsing Rust source
// 2. Replaces JsCrystal with Crystal (from matterviz) in function/method params
// 3. Adds init() wrapper and FerroxModule type
//
// Usage: node generate_types.js [--check]
//   --check: verify types.d.ts is up-to-date (exits 1 if stale)

import { readdirSync, readFileSync, writeFileSync } from 'node:fs'
import { dirname, join } from 'node:path'
import process from 'node:process'
import { fileURLToPath } from 'node:url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const WASM_SRC = join(__dirname, `..`, `src`, `wasm`)
const PKG_DTS = join(__dirname, `pkg`, `ferrox.d.ts`)
const OUT_DTS = join(__dirname, `types.d.ts`)

// === Rust type -> TypeScript type mapping ===

const RUST_TO_TS = {
  'f32': `number`,
  'f64': `number`,
  'u8': `number`,
  'u16': `number`,
  'u32': `number`,
  'u64': `number`,
  'i8': `number`,
  'i16': `number`,
  'i32': `number`,
  'i64': `number`,
  'usize': `number`,
  'bool': `boolean`,
  'String': `string`,
  '()': `void`,
}

// Convert a Rust WasmResult<T> inner type to TypeScript
function rust_type_to_ts(rust_type) {
  rust_type = rust_type.trim()

  // Option<T> -> T | null
  const option_match = rust_type.match(/^Option<(.+)>$/)
  if (option_match) {
    return `${rust_type_to_ts(option_match[1])} | null`
  }

  // Vec<Vec<T>> -> T[][]
  const nested_vec_match = rust_type.match(/^Vec<Vec<(.+)>>$/)
  if (nested_vec_match) {
    return `${rust_type_to_ts(nested_vec_match[1])}[][]`
  }

  // Vec<T> -> T[]
  const vec_match = rust_type.match(/^Vec<(.+)>$/)
  if (vec_match) {
    const inner = rust_type_to_ts(vec_match[1])
    // Wrap union types in parens for correct precedence: (T | null)[] not T | null[]
    return inner.includes(`|`) ? `(${inner})[]` : `${inner}[]`
  }

  // [[f64; 3]; 3] -> JsMatrix3x3 (already defined in generated types)
  if (rust_type === `[[f64; 3]; 3]`) return `JsMatrix3x3`

  // Primitive types
  if (RUST_TO_TS[rust_type]) return RUST_TO_TS[rust_type]

  // JsCrystal -> Crystal
  if (rust_type === `JsCrystal`) return `Crystal`

  // Pass through Js* types as-is (they're in the generated .d.ts)
  return rust_type
}

// === Parse Rust source for WasmResult<T> return types ===

function parse_rust_return_types() {
  const return_types = new Map() // fn_name -> TS return type (inner T)
  const rs_files = readdirSync(WASM_SRC).filter((file) => file.endsWith(`.rs`))

  for (const file of rs_files) {
    const content = readFileSync(join(WASM_SRC, file), `utf8`)

    // Match: pub fn name(...) -> WasmResult<T> {
    // Handles multi-line signatures by joining lines first
    const joined = content.replace(/\n\s*/g, ` `)

    for (
      const match of joined.matchAll(
        /pub fn (\w+)\s*\([^)]*\)\s*->\s*WasmResult<([^{]+?)>\s*\{/g,
      )
    ) {
      const fn_name = match[1]
      const rust_inner = match[2].trim()
      return_types.set(fn_name, rust_type_to_ts(rust_inner))
    }
  }

  return return_types
}

// === Generate types.d.ts ===

function generate() {
  let generated_dts
  try {
    generated_dts = readFileSync(PKG_DTS, `utf8`)
  } catch {
    console.error(
      `Error: ${PKG_DTS} not found. Run 'pnpm build' first to generate WASM bindings.`,
    )
    process.exit(1)
  }

  const return_types = parse_rust_return_types()

  // Replace bare WasmResult with WasmResult<T> in function declarations
  // Matches: functionName(...): WasmResult;
  let patched = generated_dts.replace(
    /(\w+)\(([^)]*)\): WasmResult;/g,
    (full_match, fn_name, params) => {
      const ts_type = return_types.get(fn_name)
      if (ts_type) {
        return `${fn_name}(${params}): WasmResult<${ts_type}>;`
      }
      // If we can't find the type, keep bare WasmResult (shouldn't happen)
      console.warn(`Warning: no return type found for ${fn_name}`)
      return full_match
    },
  )

  // Replace JsCrystal with Crystal in function/method signatures
  // (not in interface/type definitions)
  patched = patched.replace(
    /^(export function .+| {2,}\w+\(.+)\bJsCrystal\b/gm,
    (match) => match.replace(/\bJsCrystal\b/g, `Crystal`),
  )

  // Remove the tslint/eslint disable comments from generated file
  patched = patched.replace(/^\/\* tslint:disable \*\/\n\/\* eslint-disable \*\/\n/, ``)

  // Remove the default __wbg_init export and its JSDoc (we provide our own init)
  // First remove the function declaration itself
  patched = patched.replace(
    /export default function __wbg_init[^;]+;\n?/,
    ``,
  )
  // Then remove the orphaned JSDoc that preceded it (ends with @returns {Promise<InitOutput>})
  patched = patched.replace(
    /\/\*\*\n \* If `module_or_path`[\s\S]*?@returns \{Promise<InitOutput>\}\n \*\/\n/,
    ``,
  )

  // Build the final types.d.ts
  const header = `// Auto-generated by generate_types.js — do not edit manually.
// Re-run: node extensions/rust/wasm/generate_types.js
// Source: wasm-pack output (pkg/ferrox.d.ts) + Rust return types (src/wasm/*.rs)
/* eslint-disable @typescript-eslint/no-explicit-any */

export type { Crystal } from 'matterviz'
import type { Crystal } from 'matterviz'

// The module returned by init() has all exports from pkg/ferrox.js
import type * as ferrox from './pkg/ferrox.d.ts'
export type FerroxModule = typeof ferrox

export default function init(
  options?:
    | { module_or_path?: InitInput | Promise<InitInput> }
    | InitInput
    | Promise<InitInput>,
): Promise<FerroxModule>

`

  const output = header + patched.trim() + `\n`

  return output
}

// === Main ===

const check_mode = process.argv.includes(`--check`)
const output = generate()

if (check_mode) {
  // Write the generated output, then compare against git HEAD.
  // This accounts for Deno format which modifies the file during pre-commit.
  // In CI, run `deno fmt types.d.ts` after generation before checking git diff.
  writeFileSync(OUT_DTS, output)
  console.log(
    `Regenerated ${OUT_DTS} — check with 'deno fmt types.d.ts && git diff types.d.ts'`,
  )
} else {
  writeFileSync(OUT_DTS, output)
  console.log(`Generated ${OUT_DTS}`)
  const return_types = parse_rust_return_types()
  console.log(`  Typed ${return_types.size} WasmResult<T> return types from Rust source`)
}
