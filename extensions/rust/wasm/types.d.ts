// Auto-generated by generate_types.js — do not edit manually.
// Re-run: node extensions/rust/wasm/generate_types.js
// Source: wasm-pack output (pkg/ferrox.d.ts) + Rust return types (src/wasm/*.rs)
/* eslint-disable @typescript-eslint/no-explicit-any */

export type { Crystal } from 'matterviz'
import type { Crystal } from 'matterviz'

// The module returned by init() has all exports from pkg/ferrox.js
import type * as ferrox from './pkg/ferrox.d.ts'
export type FerroxModule = typeof ferrox

export default function init(
  options?:
    | { module_or_path?: InitInput | Promise<InitInput> }
    | InitInput
    | Promise<InitInput>,
): Promise<FerroxModule>

/**
 * 3D vector of floats.
 */
export type JsVector3 = [number, number, number]

/**
 * 3x3 float matrix for transformations.
 */
export type JsMatrix3x3 = [
  [number, number, number],
  [number, number, number],
  [number, number, number],
]

/**
 * 3x3 integer matrix for supercell transformations.
 */
export type JsIntMatrix3x3 = [
  [number, number, number],
  [number, number, number],
  [number, number, number],
]

/**
 * A crystal structure matching pymatgen\'s JSON format.
 */
export interface JsCrystal {
  /**
   * The crystal lattice
   */
  lattice: JsLattice
  /**
   * List of crystallographic sites
   */
  sites: JsSite[]
  /**
   * Structure-level properties
   */
  properties?: Record<string, unknown>
}

/**
 * A crystallographic site with species, coordinates, and properties.
 */
export interface JsSite {
  /**
   * Species at this site (can have multiple for disordered sites)
   */
  species: JsSpeciesOccupancy[]
  /**
   * Fractional coordinates [a, b, c] in range [0, 1)
   */
  abc: [number, number, number]
  /**
   * Cartesian coordinates [x, y, z] in Ångströms (optional, computed if missing)
   */
  xyz?: [number, number, number]
  /**
   * Site label (defaults to element symbol)
   */
  label?: string
  /**
   * Site-specific properties (e.g., magnetic moment, charge)
   */
  properties?: Record<string, unknown>
}

/**
 * A symmetry operation (rotation + translation in fractional coordinates).
 */
export interface JsSymmetryOperation {
  /**
   * 3x3 rotation matrix (integer elements in fractional basis)
   */
  rotation: [
    [number, number, number],
    [number, number, number],
    [number, number, number],
  ]
  /**
   * Translation vector in fractional coordinates
   */
  translation: [number, number, number]
}

/**
 * ASE Atoms dict format for interoperability.
 */
export interface JsAseAtoms {
  /**
   * Element symbols for each atom
   */
  symbols: string[]
  /**
   * Cartesian positions [[x1, y1, z1], ...] in Ångströms
   */
  positions: [number, number, number][]
  /**
   * Cell matrix (3x3), null for molecules
   */
  cell?: [
    [number, number, number],
    [number, number, number],
    [number, number, number],
  ]
  /**
   * Periodic boundary conditions
   */
  pbc?: [boolean, boolean, boolean]
  /**
   * Additional info dict
   */
  info?: Record<string, unknown>
}

/**
 * Element-amount pair for composition results.
 */
export interface JsElementAmount {
  /**
   * Element symbol
   */
  element: string
  /**
   * Amount (count or fraction)
   */
  amount: number
}

/**
 * Full symmetry dataset for a structure.
 */
export interface JsSymmetryDataset {
  /**
   * International space group number (1-230)
   */
  spacegroup_number: number
  /**
   * Space group symbol (e.g., \"Fm-3m\")
   */
  spacegroup_symbol: string
  /**
   * Hall number
   */
  hall_number: number
  /**
   * Crystal system (e.g., \"cubic\", \"hexagonal\")
   */
  crystal_system: string
  /**
   * Wyckoff letters for each site
   */
  wyckoff_letters: string[]
  /**
   * Site symmetry symbols for each site
   */
  site_symmetry_symbols: string[]
  /**
   * Equivalent atoms mapping
   */
  equivalent_atoms: number[]
  /**
   * Symmetry operations
   */
  operations: JsSymmetryOperation[]
}

/**
 * Information about a neighboring atom in coordination analysis.
 */
export interface JsNeighborInfo {
  /**
   * Index of the neighboring site
   */
  site_index: number
  /**
   * Element symbol of neighbor
   */
  element: string
  /**
   * Distance to neighbor (Ångströms)
   */
  distance: number
  /**
   * Periodic image offset
   */
  image: [number, number, number]
}

/**
 * Information about a parsed chemical composition.
 */
export interface JsCompositionInfo {
  /**
   * Species and their amounts as {element, amount} objects
   */
  species: JsElementAmount[]
  /**
   * Full formula string
   */
  formula: string
  /**
   * Reduced formula string (e.g., \"Fe2O3\" from \"Fe4O6\")
   */
  reducedFormula: string
  /**
   * Anonymous formula (e.g., \"A2B3\")
   */
  formulaAnonymous: string
  /**
   * Hill notation formula
   */
  formulaHill: string
  /**
   * Alphabetically sorted formula
   */
  alphabeticalFormula: string
  /**
   * Chemical system (e.g., \"Fe-O\")
   */
  chemicalSystem: string
  /**
   * Total number of atoms
   */
  numAtoms: number
  /**
   * Number of distinct elements
   */
  numElements: number
  /**
   * Molecular weight in atomic mass units
   */
  weight: number
  /**
   * True if composition is a single element
   */
  isElement: boolean
  /**
   * Average electronegativity (null if undefined)
   */
  averageElectronegativity: number | null
  /**
   * Total number of electrons
   */
  totalElectrons: number
}

/**
 * Lattice reduction algorithm.
 */
export type JsReductionAlgo = 'niggli' | 'lll'

/**
 * Lattice structure matching pymatgen\'s JSON format.
 * Includes both the 3x3 matrix and derived lattice parameters (a, b, c, alpha, beta, gamma, volume)
 * so that matterviz\'s Structure component can render without recomputing them client-side.
 */
export interface JsLattice {
  /**
   * 3x3 lattice matrix with lattice vectors as rows (Ångströms)
   */
  matrix: JsMatrix3x3
  /**
   * Periodic boundary conditions along each axis
   */
  pbc?: [boolean, boolean, boolean]
  /**
   * Lattice vector length a (Ångströms)
   */
  a?: number
  /**
   * Lattice vector length b (Ångströms)
   */
  b?: number
  /**
   * Lattice vector length c (Ångströms)
   */
  c?: number
  /**
   * Angle between b and c vectors (degrees)
   */
  alpha?: number
  /**
   * Angle between a and c vectors (degrees)
   */
  beta?: number
  /**
   * Angle between a and b vectors (degrees)
   */
  gamma?: number
  /**
   * Unit cell volume (ų)
   */
  volume?: number
}

/**
 * Local coordination environment for a site.
 */
export interface JsLocalEnvironment {
  /**
   * Index of the central site
   */
  center_index: number
  /**
   * Element at the center
   */
  center_element: string
  /**
   * Coordination number
   */
  coordination_number: number
  /**
   * List of coordinating neighbors
   */
  neighbors: JsNeighborInfo[]
}

/**
 * Metadata about a crystal structure.
 */
export interface JsStructureMetadata {
  /**
   * Number of sites
   */
  num_sites: number
  /**
   * Reduced chemical formula (e.g., \"Fe2O3\")
   */
  formula: string
  /**
   * Anonymous formula with elements replaced by A, B, C... (e.g., \"A2B3\")
   */
  formula_anonymous: string
  /**
   * Hill notation formula (C and H first if present, then alphabetical)
   */
  formula_hill: string
  /**
   * Volume in Å³
   */
  volume: number
  /**
   * Density in g/cm³ (null if zero volume)
   */
  density: number | null
  /**
   * Lattice parameters [a, b, c] in Ångströms
   */
  lattice_params: [number, number, number]
  /**
   * Lattice angles [alpha, beta, gamma] in degrees
   */
  lattice_angles: [number, number, number]
  /**
   * Whether structure is ordered (no partial occupancies)
   */
  is_ordered: boolean
}

/**
 * Miller index (3D integer vector).
 */
export type JsMillerIndex = [number, number, number]

/**
 * Miller index information for an XRD peak.
 */
export interface JsHklInfo {
  /**
   * Miller indices [h, k, l]
   */
  hkl: [number, number, number]
  /**
   * Multiplicity (number of symmetry-equivalent reflections)
   */
  multiplicity: number
}

/**
 * Result from potential energy/force calculation.
 */
export interface JsPotentialResult {
  energy: number
  /**
   * Flattened forces [fx0, fy0, fz0, fx1, fy1, fz1, ...] in eV/Å.
   */
  forces: number[]
  /**
   * Stress tensor in Voigt order: [xx, yy, zz, yz, xz, xy] in eV/Å³.
   */
  stress: [number, number, number, number, number, number] | null
}

/**
 * Result of RMS distance calculation between two structures.
 */
export interface JsRmsDistResult {
  /**
   * Root mean square distance between matched sites (Ångströms)
   */
  rms: number
  /**
   * Maximum distance between any pair of matched sites (Ångströms)
   */
  max_dist: number
}

/**
 * Result of neighbor list calculation.
 */
export interface JsNeighborList {
  /**
   * Indices of center atoms
   */
  center_indices: number[]
  /**
   * Indices of neighbor atoms
   */
  neighbor_indices: number[]
  /**
   * Periodic image offsets [h, k, l] for each neighbor
   */
  image_offsets: [number, number, number][]
  /**
   * Distances from center to neighbor (Ångströms)
   */
  distances: number[]
}

/**
 * Result wrapper that serializes to `{ ok: T }` on success or `{ error: string }` on failure.
 * TypeScript: `WasmResult<T> = { ok: T } | { error: string }`
 */
export type WasmResult<T> = { ok: T } | { error: string }

/**
 * Species occupancy at a site (element + occupancy + optional oxidation state).
 */
export interface JsSpeciesOccupancy {
  /**
   * Element symbol (e.g., \"Fe\", \"O\", \"Li\")
   */
  element: string
  /**
   * Site occupancy (0.0 to 1.0, typically 1.0 for ordered sites)
   */
  occu?: number
  /**
   * Optional oxidation state (e.g., 2 for Fe²⁺, -2 for O²⁻)
   */
  oxidation_state?: number
}

/**
 * XRD calculation options.
 */
export interface JsXrdOptions {
  /**
   * X-ray wavelength in Angstroms (default: Cu Kα = 1.54184)
   */
  wavelength?: number
  /**
   * 2θ range in degrees as [min, max]. None = all accessible angles
   */
  two_theta_range?: [number, number] | null
  /**
   * Debye-Waller factors per element symbol (thermal damping)
   */
  debye_waller_factors?: Record<string, number>
  /**
   * Whether to scale intensities to 0-100 (default: true)
   */
  scaled?: boolean
}

/**
 * XRD pattern result.
 */
export interface JsXrdPattern {
  /**
   * 2θ angles in degrees
   */
  two_theta: number[]
  /**
   * Peak intensities (scaled 0-100 if scaled=true)
   */
  intensities: number[]
  /**
   * Miller indices for each peak (grouped by unique families)
   */
  hkls: JsHklInfo[][]
  /**
   * d-spacings in Angstroms
   */
  d_spacings: number[]
}

export interface JsAseParseResult {
  type: string
  data: string
}

export interface JsNiggliResult {
  matrix: number[]
  transformation: number[]
  form: string
}

/**
 * FIRE optimizer state with cell optimization.
 */
export class JsCellFireState {
  free(): void
  [Symbol.dispose](): void
  /**
   * Check if optimization has converged.
   *
   * f_max: force convergence threshold (must be finite and positive)
   * s_max: stress convergence threshold (must be finite and positive)
   */
  is_converged(f_max: number, s_max: number): boolean
  /**
   * Get maximum force component.
   */
  max_force(): number
  /**
   * Get maximum stress component.
   */
  max_stress(): number
  /**
   * Create a new CellFIRE state.
   *
   * positions: flat array [x0, y0, z0, ...] in Angstrom
   * cell: 9-element cell matrix (row-major)
   * config: optional FIRE configuration
   * cell_factor: scaling factor for cell DOF (default: 1.0, must be positive)
   *
   * Returns an error if positions/cell contain non-finite values or cell_factor is invalid.
   */
  constructor(
    positions: Float64Array,
    cell: Float64Array,
    config?: JsFireConfig | null,
    cell_factor?: number | null,
  )
  /**
   * Get cell matrix as flat array.
   */
  readonly cell: Float64Array
  /**
   * Number of atoms.
   */
  readonly num_atoms: number
  /**
   * Get positions as flat array.
   */
  readonly positions: Float64Array
}

/**
 * JavaScript-accessible Element wrapper.
 */
export class JsElement {
  free(): void
  [Symbol.dispose](): void
  common_oxidation_states(): Int8Array
  /**
   * Create an element from its atomic number.
   */
  static from_atomic_number(atomic_num: number): JsElement
  icsd_oxidation_states(): Int8Array
  ionic_radii(): string | undefined
  ionic_radius(oxidation_state: number): number
  ionization_energies(): Float64Array
  is_actinoid(): boolean
  is_alkali(): boolean
  is_alkaline(): boolean
  is_chalcogen(): boolean
  is_halogen(): boolean
  is_lanthanoid(): boolean
  is_metal(): boolean
  is_metalloid(): boolean
  is_noble_gas(): boolean
  is_post_transition_metal(): boolean
  is_pseudo(): boolean
  is_radioactive(): boolean
  is_rare_earth(): boolean
  is_transition_metal(): boolean
  /**
   * Create an element from its symbol (e.g., "Fe", "O", "Na").
   */
  constructor(symbol: string)
  oxidation_states(): Int8Array
  shannon_ionic_radius(
    oxidation_state: number,
    coordination: string,
    spin: string,
  ): number
  shannon_radii(): string | undefined
  readonly atomic_mass: number
  readonly atomic_number: number
  readonly atomic_radius: number
  readonly block: string
  readonly boiling_point: number
  readonly covalent_radius: number
  readonly density: number
  readonly electron_affinity: number
  readonly electron_configuration: string
  readonly electron_configuration_semantic: string
  readonly electronegativity: number
  readonly first_ionization_energy: number
  readonly group: number
  readonly max_oxidation_state: number
  readonly melting_point: number
  readonly min_oxidation_state: number
  readonly molar_heat: number
  readonly n_valence: number
  readonly name: string
  readonly row: number
  readonly specific_heat: number
  readonly symbol: string
}

/**
 * FIRE optimizer configuration.
 */
export class JsFireConfig {
  free(): void
  [Symbol.dispose](): void
  /**
   * Create a new FIRE configuration with default parameters.
   */
  constructor()
  /**
   * Set maximum timestep.
   */
  set_dt_max(dt_max: number): void
  /**
   * Set initial timestep.
   */
  set_dt_start(dt_start: number): void
  /**
   * Set maximum step size in Angstrom.
   */
  set_max_step(max_step: number): void
  /**
   * Set minimum steps before dt increase.
   */
  set_n_min(n_min: number): void
}

/**
 * FIRE optimizer state.
 */
export class JsFireState {
  free(): void
  [Symbol.dispose](): void
  /**
   * Check if optimization has converged.
   *
   * f_max: force convergence threshold (must be finite and positive)
   */
  is_converged(f_max: number): boolean
  /**
   * Get maximum force component.
   */
  max_force(): number
  /**
   * Create a new FIRE state.
   *
   * positions: flat array [x0, y0, z0, ...] in Angstrom
   * config: optional FIRE configuration (uses defaults if not provided)
   *
   * Returns an error if positions length is not a multiple of 3 or contains non-finite values.
   */
  constructor(positions: Float64Array, config?: JsFireConfig | null)
  /**
   * Current timestep.
   */
  readonly dt: number
  /**
   * Number of atoms.
   */
  readonly num_atoms: number
  /**
   * Get positions as flat array.
   */
  readonly positions: Float64Array
}

/**
 * Langevin dynamics integrator for NVT ensemble.
 */
export class JsLangevinIntegrator {
  free(): void
  [Symbol.dispose](): void
  /**
   * Create a new Langevin integrator.
   *
   * temperature_k: target temperature in Kelvin (must be non-negative)
   * friction: friction coefficient in 1/fs (must be positive)
   * dt: timestep in femtoseconds (must be positive)
   * seed: optional RNG seed for reproducibility
   */
  constructor(
    temperature_k: number,
    friction: number,
    dt: number,
    seed?: bigint | null,
  )
  /**
   * Set timestep.
   */
  set_dt(dt: number): void
  /**
   * Set friction coefficient.
   */
  set_friction(friction: number): void
  /**
   * Set target temperature.
   */
  set_temperature(temperature_k: number): void
}

/**
 * MD simulation state for WASM.
 */
export class JsMDState {
  free(): void
  [Symbol.dispose](): void
  /**
   * Initialize velocities from Maxwell-Boltzmann distribution.
   */
  init_velocities(temperature_k: number, seed?: bigint | null): void
  /**
   * Compute kinetic energy in eV.
   */
  kinetic_energy(): number
  /**
   * Create a new MD state.
   *
   * positions: flat array [x0, y0, z0, x1, y1, z1, ...] in Angstrom
   * masses: array of atomic masses in amu
   */
  constructor(positions: Float64Array, masses: Float64Array)
  /**
   * Set cell matrix (9 elements, row-major).
   */
  set_cell(
    cell: Float64Array,
    pbc_x: boolean,
    pbc_y: boolean,
    pbc_z: boolean,
  ): void
  /**
   * Compute temperature in Kelvin.
   */
  temperature(): number
  /**
   * Get forces as flat array.
   */
  forces: Float64Array
  /**
   * Get masses.
   */
  readonly masses: Float64Array
  /**
   * Number of atoms.
   */
  readonly num_atoms: number
  /**
   * Get positions as flat array.
   */
  positions: Float64Array
  /**
   * Get velocities as flat array.
   */
  velocities: Float64Array
}

export class JsMsdCalculator {
  free(): void
  [Symbol.dispose](): void
  add_frame(positions: Float64Array): WasmResult<void>
  compute_msd(): Float64Array
  compute_msd_per_atom(): Float64Array
  max_lag(): number
  n_atoms(): number
  constructor(n_atoms: number, max_lag: number, origin_interval: number)
}

/**
 * NPT integrator using Parrinello-Rahman barostat.
 */
export class JsNPTIntegrator {
  free(): void
  [Symbol.dispose](): void
  /**
   * Create a new NPT integrator.
   *
   * temperature: target temperature in Kelvin (must be positive)
   * pressure: target pressure in GPa
   * tau_t: thermostat time constant in femtoseconds (must be positive)
   * tau_p: barostat time constant in femtoseconds (must be positive)
   * dt: timestep in femtoseconds (must be positive)
   * n_atoms: number of atoms
   * total_mass: total system mass in amu (must be positive)
   */
  constructor(
    temperature: number,
    pressure: number,
    tau_t: number,
    tau_p: number,
    dt: number,
    n_atoms: number,
    total_mass: number,
  )
  /**
   * Get instantaneous pressure from stress tensor.
   */
  pressure(stress: Float64Array): WasmResult<number>
}

/**
 * State for NPT molecular dynamics with variable cell.
 */
export class JsNPTState {
  free(): void
  [Symbol.dispose](): void
  /**
   * Get kinetic energy in eV.
   */
  kinetic_energy(): number
  /**
   * Create a new NPT state.
   *
   * positions: flat array [x0, y0, z0, ...] in Angstrom
   * masses: array of atomic masses in amu
   * cell: 9-element cell matrix (row-major) in Angstrom
   * pbc_x, pbc_y, pbc_z: periodic boundary conditions
   */
  constructor(
    positions: Float64Array,
    masses: Float64Array,
    cell: Float64Array,
    pbc_x: boolean,
    pbc_y: boolean,
    pbc_z: boolean,
  )
  /**
   * Get temperature in Kelvin.
   */
  temperature(): number
  /**
   * Get cell volume in Angstrom³.
   */
  volume(): number
  /**
   * Get cell matrix as flat array.
   */
  readonly cell: Float64Array
  /**
   * Number of atoms.
   */
  readonly num_atoms: number
  /**
   * Get positions as flat array.
   */
  readonly positions: Float64Array
  /**
   * Get velocities as flat array.
   */
  readonly velocities: Float64Array
}

/**
 * Nose-Hoover chain thermostat for NVT ensemble.
 */
export class JsNoseHooverChain {
  free(): void
  [Symbol.dispose](): void
  /**
   * Create a new Nose-Hoover chain thermostat.
   *
   * target_temp: target temperature in Kelvin (must be positive)
   * tau: coupling time constant in femtoseconds (must be positive)
   * dt: timestep in femtoseconds (must be positive)
   * n_dof: number of degrees of freedom (typically 3 * n_atoms - 3, must be > 0)
   */
  constructor(target_temp: number, tau: number, dt: number, n_dof: number)
  /**
   * Set target temperature.
   */
  set_temperature(target_temp: number): void
}

/**
 * RDF result containing bins and g(r) values.
 */
export class JsRdfResult {
  private constructor()
  free(): void
  [Symbol.dispose](): void
  /**
   * Get g(r) values.
   */
  readonly g_of_r: Float64Array
  /**
   * Get bin centers.
   */
  readonly radii: Float64Array
}

export class JsSpecies {
  free(): void
  [Symbol.dispose](): void
  constructor(species_str: string)
  shannon_ionic_radius(coordination: string, spin: string): number
  to_string(): string
  readonly atomic_number: number
  readonly atomic_radius: number
  readonly covalent_radius: number
  readonly electronegativity: number
  readonly ionic_radius: number
  readonly name: string
  readonly oxidation_state: number | undefined
  readonly symbol: string
}

export class JsVacfCalculator {
  free(): void
  [Symbol.dispose](): void
  add_frame(velocities: Float64Array): WasmResult<void>
  compute_normalized_vacf(): Float64Array
  compute_vacf(): Float64Array
  max_lag(): number
  n_atoms(): number
  constructor(n_atoms: number, max_lag: number, origin_interval: number)
}

/**
 * Velocity rescaling thermostat (stochastic, canonical sampling).
 */
export class JsVelocityRescale {
  free(): void
  [Symbol.dispose](): void
  /**
   * Create a new velocity rescale thermostat.
   *
   * target_temp: target temperature in Kelvin (must be positive)
   * tau: coupling time constant in femtoseconds (must be positive)
   * dt: timestep in femtoseconds (must be positive)
   * n_dof: number of degrees of freedom (must be > 0)
   * seed: optional RNG seed
   */
  constructor(
    target_temp: number,
    tau: number,
    dt: number,
    n_dof: number,
    seed?: bigint | null,
  )
  /**
   * Set target temperature.
   */
  set_temperature(target_temp: number): void
}

export class WasmStructureMatcher {
  free(): void
  [Symbol.dispose](): void
  deduplicate(structures: Crystal[]): WasmResult<number[]>
  find_matches(
    new_structures: Crystal[],
    existing_structures: Crystal[],
  ): WasmResult<(number | null)[]>
  fit(struct1: Crystal, struct2: Crystal): WasmResult<boolean>
  fit_anonymous(struct1: Crystal, struct2: Crystal): WasmResult<boolean>
  get_rms_dist(
    struct1: Crystal,
    struct2: Crystal,
  ): WasmResult<JsRmsDistResult | null>
  get_structure_distance(
    struct1: Crystal,
    struct2: Crystal,
  ): WasmResult<number>
  constructor()
  with_angle_tol(tol: number): WasmStructureMatcher
  with_element_comparator(val: boolean): WasmStructureMatcher
  with_latt_len_tol(tol: number): WasmStructureMatcher
  with_primitive_cell(val: boolean): WasmStructureMatcher
  with_scale(val: boolean): WasmStructureMatcher
  with_site_pos_tol(tol: number): WasmStructureMatcher
}

export function apply_inversion(
  structure: Crystal,
  fractional: boolean,
): WasmResult<Crystal>

export function apply_operation(
  structure: Crystal,
  rotation: JsMatrix3x3,
  translation: JsVector3,
  fractional: boolean,
): WasmResult<Crystal>

export function ase_to_pymatgen(ase_atoms: JsAseAtoms): WasmResult<string>

export function cell_delaunay_reduce(
  structure: Crystal,
  tolerance: number,
): WasmResult<string>

export function cell_find_supercell_matrix(
  structure: Crystal,
  target_atoms: number,
): WasmResult<string>

/**
 * Perform one CellFIRE optimization step with provided forces and stress.
 */
export function cell_fire_step_with_forces_and_stress(
  state: JsCellFireState,
  forces: Float64Array,
  stress: Float64Array,
): WasmResult<void>

export function cell_is_niggli_reduced(
  structure: Crystal,
  tolerance: number,
): WasmResult<boolean>

export function cell_is_supercell(
  structure: Crystal,
  other: Crystal,
  tolerance: number,
): WasmResult<string>

export function cell_lattices_equivalent(
  structure1: Crystal,
  structure2: Crystal,
  tolerance: number,
): WasmResult<boolean>

export function cell_minimum_image_distance(
  structure: Crystal,
  frac1: Float64Array,
  frac2: Float64Array,
): WasmResult<number>

export function cell_minimum_image_vector(
  structure: Crystal,
  frac1: Float64Array,
  frac2: Float64Array,
): WasmResult<string>

export function cell_niggli_reduce(
  structure: Crystal,
  tolerance: number,
): WasmResult<string>

export function cell_perpendicular_distances(
  structure: Crystal,
): WasmResult<string>

export function cell_wrap_to_unit_cell(structure: Crystal): WasmResult<Crystal>

export function classify_all_atoms(
  structure: Crystal,
  cutoff: number,
  tolerance: number,
): WasmResult<string[]>

export function classify_local_structure(
  q4: number,
  q6: number,
  tolerance: number,
): WasmResult<string>

export function composition_charge(formula: string): WasmResult<number | null>

export function compositions_almost_equal(
  formula1: string,
  formula2: string,
): WasmResult<boolean>

/**
 * Compute element-specific radial distribution function.
 */
export function compute_element_rdf(
  structure: Crystal,
  r_max: number,
  n_bins: number,
  element1: string,
  element2: string,
): WasmResult<JsRdfResult>

export function compute_harmonic_bonds(
  positions: Float64Array,
  bonds: Float64Array,
  cell: Float64Array | null | undefined,
  pbc_x: boolean,
  pbc_y: boolean,
  pbc_z: boolean,
  compute_stress: boolean,
): WasmResult<JsPotentialResult>

export function compute_lennard_jones(
  positions: Float64Array,
  cell: Float64Array | null | undefined,
  pbc_x: boolean,
  pbc_y: boolean,
  pbc_z: boolean,
  sigma: number,
  epsilon: number,
  cutoff: number | null | undefined,
  compute_stress: boolean,
): WasmResult<JsPotentialResult>

export function compute_lennard_jones_forces(
  positions: Float64Array,
  cell: Float64Array | null | undefined,
  pbc_x: boolean,
  pbc_y: boolean,
  pbc_z: boolean,
  sigma: number,
  epsilon: number,
  cutoff?: number | null,
): WasmResult<number[]>

export function compute_morse(
  positions: Float64Array,
  cell: Float64Array | null | undefined,
  pbc_x: boolean,
  pbc_y: boolean,
  pbc_z: boolean,
  d: number,
  alpha: number,
  r0: number,
  cutoff: number,
  compute_stress: boolean,
): WasmResult<JsPotentialResult>

/**
 * Compute radial distribution function.
 */
export function compute_rdf_wasm(
  structure: Crystal,
  r_max: number,
  n_bins: number,
): WasmResult<JsRdfResult>

export function compute_soft_sphere(
  positions: Float64Array,
  cell: Float64Array | null | undefined,
  pbc_x: boolean,
  pbc_y: boolean,
  pbc_z: boolean,
  sigma: number,
  epsilon: number,
  alpha: number,
  cutoff: number,
  compute_stress: boolean,
): WasmResult<JsPotentialResult>

export function compute_steinhardt_q(
  structure: Crystal,
  degree: number,
  cutoff: number,
): WasmResult<number[]>

export function compute_xrd(
  structure: Crystal,
  options?: JsXrdOptions | null,
): WasmResult<JsXrdPattern>

export function copy_structure(
  structure: Crystal,
  sanitize: boolean,
): WasmResult<Crystal>

export function defect_classify_site(coordination: number): string

export function defect_create_antisite(
  structure: Crystal,
  site_a_idx: number,
  site_b_idx: number,
): WasmResult<string>

export function defect_create_dimer(
  structure: Crystal,
  site_a_idx: number,
  site_b_idx: number,
  target_distance: number,
): WasmResult<string>

export function defect_create_interstitial(
  structure: Crystal,
  position: Float64Array,
  species: string,
): WasmResult<string>

export function defect_create_substitution(
  structure: Crystal,
  site_idx: number,
  new_species: string,
): WasmResult<string>

export function defect_create_vacancy(
  structure: Crystal,
  site_idx: number,
): WasmResult<string>

export function defect_distort_bonds(
  structure: Crystal,
  center_site_idx: number,
  distortion_factors: Float64Array,
  num_neighbors: number | null | undefined,
  cutoff: number,
): WasmResult<string>

export function defect_find_interstitial_sites(
  structure: Crystal,
  min_dist: number,
  symprec: number,
): WasmResult<string>

export function defect_find_supercell(
  structure: Crystal,
  min_image_dist: number,
  max_atoms: number,
  cubic_preference: number,
): WasmResult<number[]>

export function defect_generate_all(
  structure: Crystal,
  extrinsic_json: string,
  include_vacancies: boolean,
  include_substitutions: boolean,
  include_interstitials: boolean,
  include_antisites: boolean,
  supercell_min_dist: number,
  supercell_max_atoms: number,
  interstitial_min_dist: number | null | undefined,
  symprec: number,
  max_charge: number,
): WasmResult<string>

export function defect_generate_name(
  defect_type: string,
  species?: string | null,
  original_species?: string | null,
  wyckoff?: string | null,
  site_type?: string | null,
): WasmResult<string>

export function defect_get_wyckoff_labels(
  structure: Crystal,
  symprec: number,
): WasmResult<string>

export function defect_guess_charge_states(
  defect_type: string,
  removed_species: string | null | undefined,
  added_species: string | null | undefined,
  original_species: string | null | undefined,
  max_charge: number,
): WasmResult<string>

export function defect_local_rattle(
  structure: Crystal,
  center_site_idx: number,
  max_amplitude: number,
  decay_radius: number,
  seed: number,
): WasmResult<string>

export function defect_rattle(
  structure: Crystal,
  stdev: number,
  seed: number,
  min_distance: number,
  max_attempts: number,
): WasmResult<string>

export function diffusion_from_msd(
  msd: Float64Array,
  times: Float64Array,
  dim: number,
  start_fraction: number,
  end_fraction: number,
): WasmResult<number[]>

export function diffusion_from_vacf(
  vacf: Float64Array,
  dt: number,
  dim: number,
): WasmResult<number>

export function elastic_apply_strain(
  cell: JsMatrix3x3,
  strain: JsMatrix3x3,
): JsMatrix3x3

export function elastic_bulk_modulus(tensor: Float64Array): WasmResult<number>

export function elastic_generate_strains(
  magnitude: number,
  shear: boolean,
): WasmResult<JsMatrix3x3[]>

export function elastic_is_stable(tensor: Float64Array): WasmResult<boolean>

export function elastic_poisson_ratio(bulk: number, shear: number): number

export function elastic_shear_modulus(tensor: Float64Array): WasmResult<number>

export function elastic_strain_to_voigt(strain: JsMatrix3x3): Float64Array

export function elastic_stress_to_voigt(stress: JsMatrix3x3): Float64Array

export function elastic_tensor_from_stresses(
  strains: JsMatrix3x3[],
  stresses: JsMatrix3x3[],
): WasmResult<number[]>

export function elastic_youngs_modulus(bulk: number, shear: number): number

export function elastic_zener_ratio(
  c11: number,
  c12: number,
  c44: number,
): number

/**
 * Perform one FIRE optimization step with provided forces.
 */
export function fire_step_with_forces(
  state: JsFireState,
  forces: Float64Array,
): WasmResult<void>

export function formula_hash(formula: string): WasmResult<string>

export function fractional_composition(
  formula: string,
): WasmResult<JsElementAmount[]>

export function generate_slabs(
  structure: Crystal,
  miller_index: JsMillerIndex,
  min_slab_size: number,
  min_vacuum_size: number,
  center_slab: boolean,
  in_unit_planes: boolean,
  primitive: boolean,
  symprec: number,
): WasmResult<Crystal[]>

export function get_atomic_fraction(
  formula: string,
  element: string,
): WasmResult<number>

export function get_atomic_mass(symbol: string): WasmResult<number>

export function get_atomic_scattering_params(): string

/**
 * Get average coordination number for the structure.
 */
export function get_average_coordination_number(
  structure: Crystal,
  cutoff: number,
): WasmResult<number>

export function get_conventional(
  structure: Crystal,
  symprec: number,
): WasmResult<Crystal>

/**
 * Get coordination number for a single site.
 */
export function get_coordination_number(
  structure: Crystal,
  site_idx: number,
  cutoff: number,
): WasmResult<number>

/**
 * Get coordination numbers for all sites using cutoff distance.
 */
export function get_coordination_numbers(
  structure: Crystal,
  cutoff: number,
): WasmResult<number[]>

export function get_crystal_system(
  structure: Crystal,
  symprec: number,
): WasmResult<string>

export function get_density(structure: Crystal): WasmResult<number>

export function get_distance(
  structure: Crystal,
  site_idx_1: number,
  site_idx_2: number,
): WasmResult<number>

export function get_distance_matrix(structure: Crystal): WasmResult<number[][]>

export function get_electronegativity(symbol: string): WasmResult<number>

export function get_equivalent_sites(
  structure: Crystal,
  symprec: number,
): WasmResult<number[]>

export function get_hall_number(
  structure: Crystal,
  symprec: number,
): WasmResult<number>

export function get_lattice_inv_matrix(
  structure: Crystal,
): WasmResult<JsMatrix3x3>

export function get_lattice_metric_tensor(
  structure: Crystal,
): WasmResult<JsMatrix3x3>

export function get_lll_mapping(structure: Crystal): WasmResult<JsMatrix3x3>

export function get_lll_reduced_lattice(
  structure: Crystal,
): WasmResult<JsMatrix3x3>

export function get_local_environment(
  structure: Crystal,
  site_index: number,
  cutoff: number,
): WasmResult<JsLocalEnvironment>

export function get_neighbor_list(
  structure: Crystal,
  cutoff_radius: number,
  numerical_tol: number,
  exclude_self: boolean,
): WasmResult<JsNeighborList>

export function get_pearson_symbol(
  structure: Crystal,
  symprec: number,
): WasmResult<string>

export function get_primitive(
  structure: Crystal,
  symprec: number,
): WasmResult<Crystal>

export function get_reciprocal_lattice(
  structure: Crystal,
): WasmResult<JsMatrix3x3>

export function get_reduced_structure(
  structure: Crystal,
  algo: JsReductionAlgo,
): WasmResult<Crystal>

export function get_site_symmetry_symbols(
  structure: Crystal,
  symprec: number,
): WasmResult<string[]>

export function get_sorted_by_electronegativity(
  structure: Crystal,
  reverse: boolean,
): WasmResult<Crystal>

export function get_sorted_structure(
  structure: Crystal,
  reverse: boolean,
): WasmResult<Crystal>

export function get_spacegroup_number(
  structure: Crystal,
  symprec: number,
): WasmResult<number>

export function get_spacegroup_symbol(
  structure: Crystal,
  symprec: number,
): WasmResult<string>

export function get_structure_metadata(
  structure: Crystal,
): WasmResult<JsStructureMetadata>

export function get_symmetry_dataset(
  structure: Crystal,
  symprec: number,
): WasmResult<JsSymmetryDataset>

export function get_symmetry_operations(
  structure: Crystal,
  symprec: number,
): WasmResult<JsSymmetryOperation[]>

export function get_total_mass(structure: Crystal): WasmResult<number>

export function get_volume(structure: Crystal): WasmResult<number>

export function get_wt_fraction(
  formula: string,
  element: string,
): WasmResult<number>

export function get_wyckoff_letters(
  structure: Crystal,
  symprec: number,
): WasmResult<string[]>

export function interpolate_structures(
  start: Crystal,
  end: Crystal,
  n_images: number,
  interpolate_lattices: boolean,
  use_pbc: boolean,
): WasmResult<Crystal[]>

export function is_charge_balanced(formula: string): WasmResult<boolean | null>

export function is_periodic_image(
  structure: Crystal,
  site_i: number,
  site_j: number,
  tolerance: number,
): WasmResult<boolean>

/**
 * Complete a Langevin step after `langevin_step_init` (final velocity half-step with new
 * forces).
 *
 * new_forces: flat array of forces computed at the updated positions [Fx0, Fy0, Fz0, ...]
 */
export function langevin_step_finalize(
  integrator: JsLangevinIntegrator,
  state: JsMDState,
  new_forces: Float64Array,
): WasmResult<void>

/**
 * Perform the first part of a Langevin step (B-A-O-A: velocity half-step, position update,
 * thermostat).
 *
 * This is the split API for proper force handling:
 * 1. Call `langevin_step_init` with current forces
 * 2. Get new positions from `state.positions`
 * 3. Compute forces at new positions
 * 4. Call `langevin_step_finalize` with new forces
 *
 * forces: flat array of current forces [Fx0, Fy0, Fz0, ...] in eV/Angstrom
 */
export function langevin_step_init(
  integrator: JsLangevinIntegrator,
  state: JsMDState,
  forces: Float64Array,
): WasmResult<void>

/**
 * Perform one complete Langevin dynamics step with both old and new forces.
 *
 * This is a convenience wrapper that combines `langevin_step_init` and `langevin_step_finalize`.
 * Use this when you can pre-compute both the current forces and the forces at the new positions.
 *
 * For most use cases, prefer the split API (`langevin_step_init` + `langevin_step_finalize`)
 * which allows computing forces at the updated positions between the two calls.
 *
 * forces: flat array of current forces [Fx0, Fy0, Fz0, ...] in eV/Angstrom
 * new_forces: flat array of forces at updated positions in eV/Angstrom
 */
export function langevin_step_with_forces(
  integrator: JsLangevinIntegrator,
  state: JsMDState,
  forces: Float64Array,
  new_forces: Float64Array,
): WasmResult<void>

export function make_slab(
  structure: Crystal,
  miller_index: JsMillerIndex,
  min_slab_size: number,
  min_vacuum_size: number,
  center_slab: boolean,
  in_unit_planes: boolean,
  primitive: boolean,
  symprec: number,
  termination_index?: number | null,
): WasmResult<Crystal>

export function make_supercell(
  structure: Crystal,
  matrix: JsIntMatrix3x3,
): WasmResult<Crystal>

export function make_supercell_diag(
  structure: Crystal,
  scale_a: number,
  scale_b: number,
  scale_c: number,
): WasmResult<Crystal>

/**
 * Complete the velocity Verlet step after computing new forces.
 */
export function md_velocity_verlet_finalize(
  state: JsMDState,
  new_forces: Float64Array,
  dt_fs: number,
): WasmResult<void>

/**
 * Perform one velocity Verlet MD step (half-step velocity update + full position update).
 *
 * This function updates positions and velocities in-place. The caller must:
 * 1. Call this function with current forces
 * 2. Compute new forces at the updated positions
 * 3. Call `md_velocity_verlet_finish` with new forces to complete the velocity update
 *
 * forces: flat array of current forces [Fx0, Fy0, Fz0, ...] in eV/Angstrom
 * dt_fs: timestep in femtoseconds (must be finite and positive)
 */
export function md_velocity_verlet_step(
  state: JsMDState,
  forces: Float64Array,
  dt_fs: number,
): WasmResult<void>

export function molecule_to_ase(molecule_json: string): WasmResult<JsAseAtoms>

export function molecule_to_xyz_str(
  json: string,
  comment?: string | null,
): WasmResult<string>

/**
 * Complete a Nosé-Hoover step after `nose_hoover_step_init` (velocity half-step with new forces
 * + second thermostat half-step).
 *
 * new_forces: flat array of forces computed at the updated positions [Fx0, Fy0, Fz0, ...]
 */
export function nose_hoover_step_finalize(
  thermostat: JsNoseHooverChain,
  state: JsMDState,
  new_forces: Float64Array,
): WasmResult<void>

/**
 * Perform the first part of a Nosé-Hoover step (thermostat half-step + velocity half-step +
 * position update).
 *
 * This is the split API for proper force handling:
 * 1. Call `nose_hoover_step_init` with current forces
 * 2. Get new positions from `state.positions`
 * 3. Compute forces at new positions
 * 4. Call `nose_hoover_step_finalize` with new forces
 *
 * forces: flat array of current forces [Fx0, Fy0, Fz0, ...] in eV/Angstrom
 */
export function nose_hoover_step_init(
  thermostat: JsNoseHooverChain,
  state: JsMDState,
  forces: Float64Array,
): WasmResult<void>

/**
 * Perform one complete Nosé-Hoover chain step with both old and new forces.
 *
 * This is a convenience wrapper that combines `nose_hoover_step_init` and
 * `nose_hoover_step_finalize`.
 *
 * forces: flat array of current forces [Fx0, Fy0, Fz0, ...] in eV/Angstrom
 * new_forces: flat array of forces at updated positions in eV/Angstrom
 */
export function nose_hoover_step_with_forces(
  thermostat: JsNoseHooverChain,
  state: JsMDState,
  forces: Float64Array,
  new_forces: Float64Array,
): WasmResult<void>

/**
 * Complete an NPT step after `npt_step_init` (velocity second half + cell second half +
 * thermostat second half).
 *
 * new_forces: flat array of forces computed at the updated positions [Fx0, Fy0, Fz0, ...]
 * new_stress: 9-element stress tensor at updated configuration (row-major) in eV/Å³
 */
export function npt_step_finalize(
  integrator: JsNPTIntegrator,
  state: JsNPTState,
  new_forces: Float64Array,
  new_stress: Float64Array,
): WasmResult<void>

/**
 * Perform the first part of an NPT step (thermostat half-step + cell half-step +
 * velocity half-step + position/cell update).
 *
 * This is the split API for proper force handling:
 * 1. Call `npt_step_init` with current forces and stress
 * 2. Get new positions and cell from state
 * 3. Compute forces and stress at new configuration
 * 4. Call `npt_step_finalize` with new forces and stress
 *
 * forces: flat array of current forces [Fx0, Fy0, Fz0, ...] in eV/Angstrom
 * stress: 9-element stress tensor (row-major) in eV/Å³
 */
export function npt_step_init(
  integrator: JsNPTIntegrator,
  state: JsNPTState,
  forces: Float64Array,
  stress: Float64Array,
): WasmResult<void>

/**
 * Perform one complete NPT step with both initial and new forces/stress.
 *
 * This is a convenience wrapper that combines `npt_step_init` and `npt_step_finalize`.
 *
 * forces: flat array of initial forces [Fx0, Fy0, Fz0, ...] in eV/Angstrom
 * stress: 9-element initial stress tensor (row-major) in eV/Å³
 * new_forces: flat array of forces at updated positions in eV/Angstrom
 * new_stress: 9-element stress tensor at updated configuration in eV/Å³
 */
export function npt_step_with_forces_and_stress(
  integrator: JsNPTIntegrator,
  state: JsNPTState,
  forces: Float64Array,
  stress: Float64Array,
  new_forces: Float64Array,
  new_stress: Float64Array,
): WasmResult<void>

export function parse_ase_atoms(
  ase_atoms: JsAseAtoms,
): WasmResult<JsAseParseResult>

export function parse_cif(content: string): WasmResult<Crystal>

export function parse_composition(
  formula: string,
): WasmResult<JsCompositionInfo>

export function parse_molecule_json(json: string): WasmResult<string>

export function parse_poscar(content: string): WasmResult<Crystal>

export function parse_xyz_str(content: string): WasmResult<string>

export function perturb_structure(
  structure: Crystal,
  distance: number,
  min_distance?: number | null,
  seed?: bigint | null,
): WasmResult<Crystal>

export function reduced_composition(
  formula: string,
): WasmResult<JsElementAmount[]>

export function remove_sites(
  structure: Crystal,
  indices: Uint32Array,
): WasmResult<Crystal>

export function remove_species(
  structure: Crystal,
  species: string[],
): WasmResult<Crystal>

export function species_hash(formula: string): WasmResult<string>

export function structure_to_ase(structure: Crystal): WasmResult<JsAseAtoms>

export function structure_to_cif(structure: Crystal): WasmResult<string>

export function structure_to_json(structure: Crystal): WasmResult<string>

export function structure_to_poscar(structure: Crystal): WasmResult<string>

export function substitute_species(
  structure: Crystal,
  old_species: string,
  new_species: string,
): WasmResult<Crystal>

export function surface_area(slab: Crystal): WasmResult<number>

export function surface_calculate_energy(
  slab_energy: number,
  bulk_energy_per_atom: number,
  n_atoms: number,
  surface_area: number,
): number

export function surface_compute_wulff(
  structure: Crystal,
  surface_energies_json: string,
): WasmResult<string>

export function surface_enumerate_miller(max_index: number): WasmResult<string>

export function surface_enumerate_terminations(
  structure: Crystal,
  h: number,
  k: number,
  l: number,
  min_slab: number,
  min_vacuum: number,
  symprec: number,
): WasmResult<string>

export function surface_find_adsorption_sites(
  slab: Crystal,
  height: number,
  site_types_json: string,
  neighbor_cutoff?: number | null,
  surface_tolerance?: number | null,
): WasmResult<string>

export function surface_get_surface_atoms(
  slab: Crystal,
  tolerance: number,
): WasmResult<string>

export function surface_miller_to_normal(
  structure: Crystal,
  h: number,
  k: number,
  l: number,
): WasmResult<string>

export function translate_sites(
  structure: Crystal,
  indices: Uint32Array,
  vector: JsVector3,
  fractional: boolean,
): WasmResult<Crystal>

/**
 * Complete a velocity rescale step after `velocity_rescale_step_init` (velocity update +
 * rescaling).
 *
 * new_forces: flat array of forces computed at the updated positions [Fx0, Fy0, Fz0, ...]
 */
export function velocity_rescale_step_finalize(
  thermostat: JsVelocityRescale,
  state: JsMDState,
  new_forces: Float64Array,
): WasmResult<void>

/**
 * Perform the first part of a velocity rescale step (position update).
 *
 * This is the split API for proper force handling:
 * 1. Call `velocity_rescale_step_init` with current forces
 * 2. Get new positions from `state.positions`
 * 3. Compute forces at new positions
 * 4. Call `velocity_rescale_step_finalize` with new forces
 *
 * forces: flat array of current forces [Fx0, Fy0, Fz0, ...] in eV/Angstrom
 */
export function velocity_rescale_step_init(
  thermostat: JsVelocityRescale,
  state: JsMDState,
  forces: Float64Array,
): WasmResult<void>

/**
 * Perform one complete velocity rescale step with both old and new forces.
 *
 * This is a convenience wrapper that combines `velocity_rescale_step_init` and
 * `velocity_rescale_step_finalize`.
 *
 * forces: flat array of current forces [Fx0, Fy0, Fz0, ...] in eV/Angstrom
 * new_forces: flat array of forces at updated positions in eV/Angstrom
 */
export function velocity_rescale_step_with_forces(
  thermostat: JsVelocityRescale,
  state: JsMDState,
  forces: Float64Array,
  new_forces: Float64Array,
): WasmResult<void>

export function wrap_to_unit_cell(structure: Crystal): WasmResult<Crystal>

export type InitInput =
  | RequestInfo
  | URL
  | Response
  | BufferSource
  | WebAssembly.Module

export interface InitOutput {
  readonly memory: WebAssembly.Memory
  readonly __wbg_jsmsdcalculator_free: (a: number, b: number) => void
  readonly __wbg_jsvacfcalculator_free: (a: number, b: number) => void
  readonly __wbg_wasmstructurematcher_free: (a: number, b: number) => void
  readonly apply_inversion: (a: any, b: number) => any
  readonly apply_operation: (a: any, b: any, c: any, d: number) => any
  readonly copy_structure: (a: any, b: number) => any
  readonly diffusion_from_msd: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
  ) => any
  readonly diffusion_from_vacf: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly elastic_apply_strain: (a: any, b: any) => any
  readonly elastic_bulk_modulus: (a: number, b: number) => any
  readonly elastic_generate_strains: (a: number, b: number) => any
  readonly elastic_is_stable: (a: number, b: number) => any
  readonly elastic_poisson_ratio: (a: number, b: number) => number
  readonly elastic_shear_modulus: (a: number, b: number) => any
  readonly elastic_strain_to_voigt: (a: any) => [number, number]
  readonly elastic_stress_to_voigt: (a: any) => [number, number]
  readonly elastic_tensor_from_stresses: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly elastic_youngs_modulus: (a: number, b: number) => number
  readonly elastic_zener_ratio: (a: number, b: number, c: number) => number
  readonly get_density: (a: any) => any
  readonly get_sorted_by_electronegativity: (a: any, b: number) => any
  readonly get_sorted_structure: (a: any, b: number) => any
  readonly get_structure_metadata: (a: any) => any
  readonly get_total_mass: (a: any) => any
  readonly get_volume: (a: any) => any
  readonly interpolate_structures: (
    a: any,
    b: any,
    c: number,
    d: number,
    e: number,
  ) => any
  readonly jsmsdcalculator_add_frame: (a: number, b: number, c: number) => any
  readonly jsmsdcalculator_compute_msd: (a: number) => [number, number]
  readonly jsmsdcalculator_compute_msd_per_atom: (
    a: number,
  ) => [number, number]
  readonly jsmsdcalculator_max_lag: (a: number) => number
  readonly jsmsdcalculator_n_atoms: (a: number) => number
  readonly jsmsdcalculator_new: (
    a: number,
    b: number,
    c: number,
  ) => [number, number, number]
  readonly jsvacfcalculator_add_frame: (a: number, b: number, c: number) => any
  readonly jsvacfcalculator_compute_normalized_vacf: (
    a: number,
  ) => [number, number]
  readonly jsvacfcalculator_compute_vacf: (a: number) => [number, number]
  readonly jsvacfcalculator_new: (
    a: number,
    b: number,
    c: number,
  ) => [number, number, number]
  readonly perturb_structure: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
    f: bigint,
  ) => any
  readonly remove_sites: (a: any, b: number, c: number) => any
  readonly remove_species: (a: any, b: number, c: number) => any
  readonly substitute_species: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
  ) => any
  readonly translate_sites: (
    a: any,
    b: number,
    c: number,
    d: any,
    e: number,
  ) => any
  readonly wasmstructurematcher_deduplicate: (
    a: number,
    b: number,
    c: number,
  ) => any
  readonly wasmstructurematcher_find_matches: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
  ) => any
  readonly wasmstructurematcher_fit: (a: number, b: any, c: any) => any
  readonly wasmstructurematcher_fit_anonymous: (
    a: number,
    b: any,
    c: any,
  ) => any
  readonly wasmstructurematcher_get_rms_dist: (
    a: number,
    b: any,
    c: any,
  ) => any
  readonly wasmstructurematcher_get_structure_distance: (
    a: number,
    b: any,
    c: any,
  ) => any
  readonly wasmstructurematcher_new: () => number
  readonly wasmstructurematcher_with_angle_tol: (
    a: number,
    b: number,
  ) => number
  readonly wasmstructurematcher_with_element_comparator: (
    a: number,
    b: number,
  ) => number
  readonly wasmstructurematcher_with_latt_len_tol: (
    a: number,
    b: number,
  ) => number
  readonly wasmstructurematcher_with_primitive_cell: (
    a: number,
    b: number,
  ) => number
  readonly wasmstructurematcher_with_scale: (a: number, b: number) => number
  readonly wasmstructurematcher_with_site_pos_tol: (
    a: number,
    b: number,
  ) => number
  readonly wrap_to_unit_cell: (a: any) => any
  readonly jsvacfcalculator_max_lag: (a: number) => number
  readonly jsvacfcalculator_n_atoms: (a: number) => number
  readonly __wbg_jselement_free: (a: number, b: number) => void
  readonly get_atomic_mass: (a: number, b: number) => any
  readonly get_electronegativity: (a: number, b: number) => any
  readonly jselement_atomic_mass: (a: number) => number
  readonly jselement_atomic_number: (a: number) => number
  readonly jselement_atomic_radius: (a: number) => number
  readonly jselement_block: (a: number) => [number, number]
  readonly jselement_boiling_point: (a: number) => number
  readonly jselement_common_oxidation_states: (a: number) => [number, number]
  readonly jselement_covalent_radius: (a: number) => number
  readonly jselement_density: (a: number) => number
  readonly jselement_electron_affinity: (a: number) => number
  readonly jselement_electron_configuration: (a: number) => [number, number]
  readonly jselement_electron_configuration_semantic: (
    a: number,
  ) => [number, number]
  readonly jselement_electronegativity: (a: number) => number
  readonly jselement_first_ionization_energy: (a: number) => number
  readonly jselement_from_atomic_number: (
    a: number,
  ) => [number, number, number]
  readonly jselement_group: (a: number) => number
  readonly jselement_icsd_oxidation_states: (a: number) => [number, number]
  readonly jselement_ionic_radii: (a: number) => [number, number]
  readonly jselement_ionic_radius: (a: number, b: number) => number
  readonly jselement_ionization_energies: (a: number) => [number, number]
  readonly jselement_is_actinoid: (a: number) => number
  readonly jselement_is_alkali: (a: number) => number
  readonly jselement_is_alkaline: (a: number) => number
  readonly jselement_is_chalcogen: (a: number) => number
  readonly jselement_is_halogen: (a: number) => number
  readonly jselement_is_lanthanoid: (a: number) => number
  readonly jselement_is_metal: (a: number) => number
  readonly jselement_is_metalloid: (a: number) => number
  readonly jselement_is_noble_gas: (a: number) => number
  readonly jselement_is_post_transition_metal: (a: number) => number
  readonly jselement_is_pseudo: (a: number) => number
  readonly jselement_is_radioactive: (a: number) => number
  readonly jselement_is_rare_earth: (a: number) => number
  readonly jselement_is_transition_metal: (a: number) => number
  readonly jselement_max_oxidation_state: (a: number) => number
  readonly jselement_melting_point: (a: number) => number
  readonly jselement_min_oxidation_state: (a: number) => number
  readonly jselement_molar_heat: (a: number) => number
  readonly jselement_n_valence: (a: number) => number
  readonly jselement_name: (a: number) => [number, number]
  readonly jselement_new: (a: number, b: number) => [number, number, number]
  readonly jselement_oxidation_states: (a: number) => [number, number]
  readonly jselement_row: (a: number) => number
  readonly jselement_shannon_ionic_radius: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
  ) => number
  readonly jselement_shannon_radii: (a: number) => [number, number]
  readonly jselement_specific_heat: (a: number) => number
  readonly jselement_symbol: (a: number) => [number, number]
  readonly classify_all_atoms: (a: any, b: number, c: number) => any
  readonly classify_local_structure: (a: number, b: number, c: number) => any
  readonly compute_harmonic_bonds: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
    j: number,
  ) => any
  readonly compute_lennard_jones: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
    j: number,
    k: number,
    l: number,
  ) => any
  readonly compute_lennard_jones_forces: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
    j: number,
    k: number,
  ) => any
  readonly compute_morse: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
    j: number,
    k: number,
    l: number,
  ) => any
  readonly compute_soft_sphere: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
    j: number,
    k: number,
    l: number,
  ) => any
  readonly compute_steinhardt_q: (a: any, b: number, c: number) => any
  readonly compute_xrd: (a: any, b: number) => any
  readonly get_atomic_scattering_params: () => [number, number]
  readonly get_average_coordination_number: (a: any, b: number) => any
  readonly get_coordination_number: (a: any, b: number, c: number) => any
  readonly get_coordination_numbers: (a: any, b: number) => any
  readonly get_distance: (a: any, b: number, c: number) => any
  readonly get_distance_matrix: (a: any) => any
  readonly get_local_environment: (a: any, b: number, c: number) => any
  readonly get_neighbor_list: (a: any, b: number, c: number, d: number) => any
  readonly __wbg_jsrdfresult_free: (a: number, b: number) => void
  readonly __wbg_jsspecies_free: (a: number, b: number) => void
  readonly ase_to_pymatgen: (a: any) => any
  readonly compute_element_rdf: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
  ) => any
  readonly compute_rdf_wasm: (a: any, b: number, c: number) => any
  readonly defect_classify_site: (a: number) => [number, number]
  readonly defect_create_antisite: (a: any, b: number, c: number) => any
  readonly defect_create_dimer: (
    a: any,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly defect_create_interstitial: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
  ) => any
  readonly defect_create_substitution: (
    a: any,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly defect_create_vacancy: (a: any, b: number) => any
  readonly defect_distort_bonds: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
  ) => any
  readonly defect_find_interstitial_sites: (
    a: any,
    b: number,
    c: number,
  ) => any
  readonly defect_find_supercell: (
    a: any,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly defect_generate_all: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
    j: number,
    k: number,
    l: number,
    m: number,
  ) => any
  readonly defect_generate_name: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
    j: number,
  ) => any
  readonly defect_get_wyckoff_labels: (a: any, b: number) => any
  readonly defect_guess_charge_states: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
  ) => any
  readonly defect_local_rattle: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
  ) => any
  readonly defect_rattle: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
  ) => any
  readonly get_conventional: (a: any, b: number) => any
  readonly get_crystal_system: (a: any, b: number) => any
  readonly get_equivalent_sites: (a: any, b: number) => any
  readonly get_hall_number: (a: any, b: number) => any
  readonly get_lattice_inv_matrix: (a: any) => any
  readonly get_lattice_metric_tensor: (a: any) => any
  readonly get_lll_mapping: (a: any) => any
  readonly get_lll_reduced_lattice: (a: any) => any
  readonly get_pearson_symbol: (a: any, b: number) => any
  readonly get_primitive: (a: any, b: number) => any
  readonly get_reciprocal_lattice: (a: any) => any
  readonly get_reduced_structure: (a: any, b: any) => any
  readonly get_site_symmetry_symbols: (a: any, b: number) => any
  readonly get_spacegroup_number: (a: any, b: number) => any
  readonly get_spacegroup_symbol: (a: any, b: number) => any
  readonly get_symmetry_dataset: (a: any, b: number) => any
  readonly get_symmetry_operations: (a: any, b: number) => any
  readonly get_wyckoff_letters: (a: any, b: number) => any
  readonly is_periodic_image: (a: any, b: number, c: number, d: number) => any
  readonly jsrdfresult_g_of_r: (a: number) => [number, number]
  readonly jsrdfresult_radii: (a: number) => [number, number]
  readonly jsspecies_atomic_number: (a: number) => number
  readonly jsspecies_atomic_radius: (a: number) => number
  readonly jsspecies_covalent_radius: (a: number) => number
  readonly jsspecies_electronegativity: (a: number) => number
  readonly jsspecies_ionic_radius: (a: number) => number
  readonly jsspecies_name: (a: number) => [number, number]
  readonly jsspecies_new: (a: number, b: number) => [number, number, number]
  readonly jsspecies_oxidation_state: (a: number) => number
  readonly jsspecies_shannon_ionic_radius: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
  ) => number
  readonly jsspecies_symbol: (a: number) => [number, number]
  readonly jsspecies_to_string: (a: number) => [number, number]
  readonly molecule_to_ase: (a: number, b: number) => any
  readonly molecule_to_xyz_str: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly parse_ase_atoms: (a: any) => any
  readonly parse_cif: (a: number, b: number) => any
  readonly parse_molecule_json: (a: number, b: number) => any
  readonly parse_poscar: (a: number, b: number) => any
  readonly parse_xyz_str: (a: number, b: number) => any
  readonly structure_to_ase: (a: any) => any
  readonly structure_to_cif: (a: any) => any
  readonly structure_to_json: (a: any) => any
  readonly structure_to_poscar: (a: any) => any
  readonly __wbg_jscellfirestate_free: (a: number, b: number) => void
  readonly __wbg_jsfireconfig_free: (a: number, b: number) => void
  readonly __wbg_jsfirestate_free: (a: number, b: number) => void
  readonly __wbg_jslangevinintegrator_free: (a: number, b: number) => void
  readonly __wbg_jsmdstate_free: (a: number, b: number) => void
  readonly __wbg_jsnosehooverchain_free: (a: number, b: number) => void
  readonly __wbg_jsnptintegrator_free: (a: number, b: number) => void
  readonly __wbg_jsnptstate_free: (a: number, b: number) => void
  readonly __wbg_jsvelocityrescale_free: (a: number, b: number) => void
  readonly cell_delaunay_reduce: (a: any, b: number) => any
  readonly cell_find_supercell_matrix: (a: any, b: number) => any
  readonly cell_fire_step_with_forces_and_stress: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
  ) => any
  readonly cell_is_niggli_reduced: (a: any, b: number) => any
  readonly cell_is_supercell: (a: any, b: any, c: number) => any
  readonly cell_lattices_equivalent: (a: any, b: any, c: number) => any
  readonly cell_minimum_image_distance: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
  ) => any
  readonly cell_minimum_image_vector: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
  ) => any
  readonly cell_niggli_reduce: (a: any, b: number) => any
  readonly cell_perpendicular_distances: (a: any) => any
  readonly cell_wrap_to_unit_cell: (a: any) => any
  readonly composition_charge: (a: number, b: number) => any
  readonly compositions_almost_equal: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly fire_step_with_forces: (a: number, b: number, c: number) => any
  readonly formula_hash: (a: number, b: number) => any
  readonly fractional_composition: (a: number, b: number) => any
  readonly generate_slabs: (
    a: any,
    b: any,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
  ) => any
  readonly get_atomic_fraction: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly get_wt_fraction: (a: number, b: number, c: number, d: number) => any
  readonly is_charge_balanced: (a: number, b: number) => any
  readonly jscellfirestate_cell: (a: number) => [number, number]
  readonly jscellfirestate_is_converged: (
    a: number,
    b: number,
    c: number,
  ) => [number, number, number]
  readonly jscellfirestate_max_force: (a: number) => number
  readonly jscellfirestate_max_stress: (a: number) => number
  readonly jscellfirestate_new: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
  ) => [number, number, number]
  readonly jscellfirestate_num_atoms: (a: number) => number
  readonly jscellfirestate_positions: (a: number) => [number, number]
  readonly jsfireconfig_new: () => number
  readonly jsfireconfig_set_dt_max: (a: number, b: number) => void
  readonly jsfireconfig_set_dt_start: (a: number, b: number) => void
  readonly jsfireconfig_set_max_step: (a: number, b: number) => void
  readonly jsfireconfig_set_n_min: (a: number, b: number) => void
  readonly jsfirestate_dt: (a: number) => number
  readonly jsfirestate_is_converged: (
    a: number,
    b: number,
  ) => [number, number, number]
  readonly jsfirestate_max_force: (a: number) => number
  readonly jsfirestate_new: (
    a: number,
    b: number,
    c: number,
  ) => [number, number, number]
  readonly jsfirestate_num_atoms: (a: number) => number
  readonly jsfirestate_positions: (a: number) => [number, number]
  readonly jslangevinintegrator_new: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: bigint,
  ) => [number, number, number]
  readonly jslangevinintegrator_set_dt: (
    a: number,
    b: number,
  ) => [number, number]
  readonly jslangevinintegrator_set_friction: (
    a: number,
    b: number,
  ) => [number, number]
  readonly jslangevinintegrator_set_temperature: (
    a: number,
    b: number,
  ) => [number, number]
  readonly jsmdstate_forces: (a: number) => [number, number]
  readonly jsmdstate_init_velocities: (
    a: number,
    b: number,
    c: number,
    d: bigint,
  ) => [number, number]
  readonly jsmdstate_kinetic_energy: (a: number) => number
  readonly jsmdstate_masses: (a: number) => [number, number]
  readonly jsmdstate_new: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => [number, number, number]
  readonly jsmdstate_num_atoms: (a: number) => number
  readonly jsmdstate_positions: (a: number) => [number, number]
  readonly jsmdstate_set_cell: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
  ) => [number, number]
  readonly jsmdstate_set_forces: (
    a: number,
    b: number,
    c: number,
  ) => [number, number]
  readonly jsmdstate_set_positions: (
    a: number,
    b: number,
    c: number,
  ) => [number, number]
  readonly jsmdstate_set_velocities: (
    a: number,
    b: number,
    c: number,
  ) => [number, number]
  readonly jsmdstate_temperature: (a: number) => number
  readonly jsmdstate_velocities: (a: number) => [number, number]
  readonly jsnosehooverchain_new: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => [number, number, number]
  readonly jsnosehooverchain_set_temperature: (
    a: number,
    b: number,
  ) => [number, number]
  readonly jsnptintegrator_new: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
  ) => [number, number, number]
  readonly jsnptintegrator_pressure: (a: number, b: number, c: number) => any
  readonly jsnptstate_cell: (a: number) => [number, number]
  readonly jsnptstate_kinetic_energy: (a: number) => number
  readonly jsnptstate_new: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
  ) => [number, number, number]
  readonly jsnptstate_num_atoms: (a: number) => number
  readonly jsnptstate_positions: (a: number) => [number, number]
  readonly jsnptstate_temperature: (a: number) => number
  readonly jsnptstate_velocities: (a: number) => [number, number]
  readonly jsnptstate_volume: (a: number) => number
  readonly jsvelocityrescale_new: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: bigint,
  ) => [number, number, number]
  readonly jsvelocityrescale_set_temperature: (
    a: number,
    b: number,
  ) => [number, number]
  readonly langevin_step_finalize: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly langevin_step_init: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly langevin_step_with_forces: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
  ) => any
  readonly make_slab: (
    a: any,
    b: any,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
  ) => any
  readonly make_supercell: (a: any, b: any) => any
  readonly make_supercell_diag: (
    a: any,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly md_velocity_verlet_finalize: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly md_velocity_verlet_step: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly nose_hoover_step_finalize: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly nose_hoover_step_init: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly nose_hoover_step_with_forces: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
  ) => any
  readonly npt_step_finalize: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
  ) => any
  readonly npt_step_init: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
  ) => any
  readonly npt_step_with_forces_and_stress: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number,
    j: number,
  ) => any
  readonly parse_composition: (a: number, b: number) => any
  readonly reduced_composition: (a: number, b: number) => any
  readonly species_hash: (a: number, b: number) => any
  readonly surface_area: (a: any) => any
  readonly surface_calculate_energy: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => number
  readonly surface_compute_wulff: (a: any, b: number, c: number) => any
  readonly surface_enumerate_miller: (a: number) => any
  readonly surface_enumerate_terminations: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
  ) => any
  readonly surface_find_adsorption_sites: (
    a: any,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
  ) => any
  readonly surface_get_surface_atoms: (a: any, b: number) => any
  readonly surface_miller_to_normal: (
    a: any,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly velocity_rescale_step_finalize: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly velocity_rescale_step_init: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => any
  readonly velocity_rescale_step_with_forces: (
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
  ) => any
  readonly __wbindgen_malloc: (a: number, b: number) => number
  readonly __wbindgen_realloc: (
    a: number,
    b: number,
    c: number,
    d: number,
  ) => number
  readonly __wbindgen_exn_store: (a: number) => void
  readonly __externref_table_alloc: () => number
  readonly __wbindgen_externrefs: WebAssembly.Table
  readonly __wbindgen_free: (a: number, b: number, c: number) => void
  readonly __externref_table_dealloc: (a: number) => void
  readonly __wbindgen_start: () => void
}

export type SyncInitInput = BufferSource | WebAssembly.Module

/**
 * Instantiates the given `module`, which can either be bytes or
 * a precompiled `WebAssembly.Module`.
 *
 * @param {{ module: SyncInitInput }} module - Passing `SyncInitInput` directly is deprecated.
 *
 * @returns {InitOutput}
 */
export function initSync(
  module: { module: SyncInitInput } | SyncInitInput,
): InitOutput
