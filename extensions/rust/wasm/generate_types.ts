#!/usr/bin/env -S deno run -A
// Auto-generate types.d.ts from wasm-pack output + Rust source.
// Reads pkg/ferrox.d.ts (generated by wasm-pack) and patches it:
// 1. Adds typed WasmResult<T> parameters by parsing Rust source
// 2. Replaces JsCrystal with Crystal (from matterviz) in function/method params
// 3. Removes duplicate Js* types that exist in matterviz
// 4. Adds init() wrapper and FerroxModule type
//
// Usage: deno run -A generate_types.ts

import { readdirSync, readFileSync, writeFileSync } from 'node:fs'
import { dirname, join } from 'node:path'
import process from 'node:process'
import { fileURLToPath } from 'node:url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const WASM_SRC = join(__dirname, `..`, `src`, `wasm`)
const PKG_DTS = join(__dirname, `pkg`, `ferrox.d.ts`)
const OUT_DTS = join(__dirname, `types.d.ts`)

// === Rust type -> TypeScript type mapping ===

const RUST_TO_TS: Record<string, string> = {
  'f32': `number`,
  'f64': `number`,
  'u8': `number`,
  'u16': `number`,
  'u32': `number`,
  'u64': `number`,
  'i8': `number`,
  'i16': `number`,
  'i32': `number`,
  'i64': `number`,
  'usize': `number`,
  'bool': `boolean`,
  'String': `string`,
  '()': `void`,
}

const RUST_SPECIAL: Record<string, string> = {
  '[[f64; 3]; 3]': `Matrix3x3`,
  'JsCrystal': `Crystal`,
}

// Convert a Rust WasmResult<T> inner type to TypeScript
function rust_type_to_ts(rust_type: string): string {
  rust_type = rust_type.trim()

  const option_match = rust_type.match(/^Option<(.+)>$/)
  if (option_match) return `${rust_type_to_ts(option_match[1])} | null`

  // Vec<T> -> T[] (handles Vec<Vec<T>> -> T[][] via recursion)
  const vec_match = rust_type.match(/^Vec<(.+)>$/)
  if (vec_match) {
    const inner = rust_type_to_ts(vec_match[1])
    return inner.includes(`|`) ? `(${inner})[]` : `${inner}[]`
  }

  return RUST_TO_TS[rust_type] ?? RUST_SPECIAL[rust_type] ?? rust_type
}

// === Parse Rust source for WasmResult<T> return types ===

function parse_rust_return_types(): Map<string, string> {
  const return_types = new Map<string, string>()
  const rs_files = readdirSync(WASM_SRC).filter((file) => file.endsWith(`.rs`))

  for (const file of rs_files) {
    const content = readFileSync(join(WASM_SRC, file), `utf8`)

    // Strip line and block comments, then join lines for multi-line sig matching
    const joined = content
      .replace(/^\s*\/\/.*$/gm, ``)
      .replace(/\/\*[\s\S]*?\*\//g, ``)
      .replace(/\n\s*/g, ` `)

    for (
      const match of joined.matchAll(
        /pub fn (\w+)\s*\([^)]*\)\s*->\s*WasmResult<([^{]+?)>\s*\{/g,
      )
    ) {
      return_types.set(match[1], rust_type_to_ts(match[2].trim()))
    }
  }

  return return_types
}

// === Generate types.d.ts ===

function generate(): { output: string; n_typed: number } {
  let generated_dts: string
  try {
    generated_dts = readFileSync(PKG_DTS, `utf8`)
  } catch {
    console.error(
      `Error: ${PKG_DTS} not found. Run 'pnpm build' first to generate WASM bindings.`,
    )
    process.exit(1)
  }

  const return_types = parse_rust_return_types()
  const n_typed = return_types.size

  // Replace bare WasmResult with WasmResult<T> in function declarations
  let patched = generated_dts.replace(
    /(\w+)\(([^)]*)\): WasmResult;/g,
    (full_match: string, fn_name: string, params: string) => {
      const ts_type = return_types.get(fn_name)
      if (ts_type) return `${fn_name}(${params}): WasmResult<${ts_type}>;`
      console.warn(`Warning: no return type found for ${fn_name}`)
      return full_match
    },
  )

  // Replace JsCrystal with Crystal in function/method signatures
  patched = patched.replace(
    /^(export function .+| {2,}\w+\(.+)\bJsCrystal\b/gm,
    (match: string) => match.replace(/\bJsCrystal\b/g, `Crystal`),
  )

  // Fix tsify Map<string, X> -> Record<string, X>
  patched = patched.replace(/\bMap<string,\s*([^>]+)>/g, `Record<string, $1>`)

  // Fix tsify's undefined `Value` type (from serde_json::Value) -> unknown
  patched = patched.replace(/\bValue\b/g, `unknown`)

  // Fix tsify referencing Rust type alias `Matrix3x3` instead of `JsMatrix3x3`
  patched = patched.replace(/\bMatrix3x3\b(?![\w[])/g, `JsMatrix3x3`)

  // DRY: remove Js* type/interface definitions that duplicate matterviz types,
  // then rename remaining references. Remove BEFORE renaming so regexes match
  // original Js* names. Line-based removal avoids greedy cross-definition regex.
  const dead_types = [`JsVector3`, `JsMatrix3x3`, `JsIntMatrix3x3`, `JsMillerIndex`]
  const dead_interfaces = [`JsCrystal`, `JsSite`, `JsSpeciesOccupancy`, `JsLattice`]

  {
    const lines = patched.split(`\n`)
    const filtered: string[] = []
    let skip_until = -1

    for (let idx = 0; idx < lines.length; idx++) {
      if (idx <= skip_until) continue
      const trimmed = lines[idx].trimStart()

      const is_dead_type = dead_types.some((name) =>
        trimmed.startsWith(`export type ${name}`)
      )
      const dead_iface = dead_interfaces.find((name) =>
        trimmed.startsWith(`export interface ${name} {`)
      )

      if (is_dead_type || dead_iface) {
        // Remove preceding JSDoc block
        while (filtered.length > 0) {
          const prev = filtered.at(-1)?.trimStart() ?? ``
          if (prev.startsWith(`*`) || prev.startsWith(`/**`)) filtered.pop()
          else break
        }
        // For interfaces, skip until closing brace
        if (dead_iface) {
          let depth = 0
          for (let jj = idx; jj < lines.length; jj++) {
            if (lines[jj].includes(`{`)) depth++
            if (lines[jj].includes(`}`)) depth--
            if (depth === 0) {
              skip_until = jj
              break
            }
          }
        }
        continue
      }

      filtered.push(lines[idx])
    }
    patched = filtered.join(`\n`)
  }

  // Rename remaining Js* references to matterviz equivalents
  patched = patched.replace(/\bJsVector3\b/g, `Vec3`)
  patched = patched.replace(/\bJsMatrix3x3\b/g, `Matrix3x3`)
  patched = patched.replace(/\bJsIntMatrix3x3\b/g, `Matrix3x3`)
  patched = patched.replace(/\bJsMillerIndex\b/g, `Vec3`)

  // Fix tsify Option<T> in interface fields: "| undefined" -> "| null"
  // serde serializes None as null, not undefined. Only fix interface fields
  // (indented, no `readonly`, no `()` before `:`), not class methods/getters.
  patched = patched.replace(
    /^(\s+(?!readonly\s)\w[\w?]*: .+) \| undefined;$/gm,
    `$1 | null;`,
  )

  // Remove tslint/eslint disable comments
  patched = patched.replace(/^\/\* tslint:disable \*\/\n\/\* eslint-disable \*\/\n/, ``)

  // Remove wasm-bindgen internal init plumbing (before semicolon stripping)
  patched = patched.replace(/\nexport interface InitOutput \{[\s\S]*?\n\}\n/, `\n`)
  patched = patched.replace(/\nexport type SyncInitInput[^\n]*\n/, `\n`)
  patched = patched.replace(
    /\n\/\*\*\n \* Instantiates[\s\S]*?\*\/\nexport function initSync[^\n]*\n/,
    `\n`,
  )
  patched = patched.replace(
    /\n\/\*\*\n \* If `module_or_path`[\s\S]*?\*\/\nexport default function __wbg_init[^\n]*\n/,
    `\n`,
  )

  // Strip semicolons (project uses semiColons: false in deno.jsonc)
  patched = patched.replace(/;$/gm, ``)

  const header = `// Auto-generated by generate_types.ts â€” do not edit manually.
// Re-run: deno run -A extensions/rust/wasm/generate_types.ts
// Source: wasm-pack output (pkg/ferrox.d.ts) + Rust return types (src/wasm/*.rs)

export type { Crystal, Matrix3x3, Vec3 } from 'matterviz'
import type { Crystal, Matrix3x3, Vec3 } from 'matterviz'

// The module returned by init() has all exports from pkg/ferrox.js
import * as ferrox from './pkg/ferrox.d.ts'
export type FerroxModule = typeof ferrox

export default function init(
  options?:
    | { module_or_path?: InitInput | Promise<InitInput> }
    | InitInput
    | Promise<InitInput>,
): Promise<FerroxModule>

`

  return { output: header + patched.trim() + `\n`, n_typed }
}

// === Main ===

const { output, n_typed } = generate()
writeFileSync(OUT_DTS, output)
console.log(`Generated ${OUT_DTS} (${n_typed} typed WasmResult<T> return types)`)
